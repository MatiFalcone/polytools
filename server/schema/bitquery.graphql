"""Account"""
type Account {
  """Account ID"""
  id: String!

  """Account number, the equivalent of a human-friendly public key"""
  num: Int!

  """Realm number """
  realmId: Int!

  """Shard number"""
  shardId: Int!
}

"""Solana Action"""
type Action {
  name: String!
  type: String!
}

"""Blockchain address"""
type Address {
  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String
}

"""Address selector"""
input AddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: [String!]

  """Not in the list of Addresses"""
  notIn: [String!]
}

"""Address selector"""
input AddressSelectorIn {
  """Equal to Address"""
  is: String

  """In the list of Addresses"""
  in: String
}

"""Blockchain account with address and type"""
type AddressWithAccount {
  """Account ID"""
  account: String!

  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String

  """Account type"""
  type: String!
}

"""Algorand Blockchain"""
type Algorand {
  """Basic information about address ( or smart contract )"""
  address(address: [AlgorandAddressSelector!]!): [AlgorandAddressInfo!]!

  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AlgorandAddressSelector!], caller: [AlgorandAddressSelector!], reference: [AlgorandAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AlgorandAddressSelector!], argindex: ArgumentIndexSelector, any: [AlgorandArgumentFilter!], options: QueryOptions): [AlgorandArguments!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector, any: [AlgorandBlockFilter!], options: QueryOptions): [AlgorandBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AlgorandAddressSelector, receiver: AlgorandAddressSelector, currency: [AlgorandCurrencySelector!], initialAddress: AlgorandAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [AlgorandCoinpath!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AlgorandAddressSelector!], smartContractAddress: [AlgorandAddressSelector!], txType: TxTypeSelector, any: [AlgorandSmartContractCallFilter!], options: QueryOptions): [AlgorandSmartContractCalls!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, any: [AlgorandTransactionFilter!], options: QueryOptions): [AlgorandTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, sender: [AlgorandAddressSelector!], receiver: [AlgorandAddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector, any: [AlgorandTransferFilter!], options: QueryOptions): [AlgorandTransfers!]
}

"""Address detailed information for Algorand network"""
type AlgorandAddressInfo {
  """Address"""
  address: Address

  """Smart Contract if exists on the address"""
  smartContract: AlgorandSmartContract
}

"""Algorand Address"""
input AlgorandAddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: [String!]

  """Not in the list of Addresses"""
  notIn: [String!]
}

input AlgorandArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txType: TxTypeSelector
  txFrom: [AlgorandAddressSelector!]
  caller: [AlgorandAddressSelector!]
  reference: [AlgorandAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  smartContractAddress: [AlgorandAddressSelector!]
  argindex: ArgumentIndexSelector
}

"""Arguments of Smart Contract Calls"""
type AlgorandArguments {
  any(of: AlgorandArgumentsMeasureable!): String

  """Sequential index of value in array ( multi-dimensional)"""
  argindex: Int!

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AlgorandAddressSelector!], caller: [AlgorandAddressSelector!], reference: [AlgorandAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AlgorandAddressSelector!], argindex: ArgumentIndexSelector): Int

  """Calendar date"""
  date: Date
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  minimum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  note: String
  poolerror: String

  """Smart contract being called"""
  smartContract(smartContractAddress: [AlgorandAddressSelector!]): AlgorandSmartContract

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [AlgorandAddressSelector!]): TransactionHashIndex

  """Transaction sender"""
  txSender(txSender: [AlgorandAddressSelector!]): Address

  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType

  """The Value of argument"""
  value(value: [ArgumentValueSelector!]): String
}

enum AlgorandArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction type"""
  tx_type

  """Transaction Sender"""
  tx_sender

  """Smart Contract"""
  smart_contract

  """Argument value"""
  argument_value

  """Argument index"""
  argument_index
}

input AlgorandBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: [AlgorandAddressSelector!]
  blockReward: [AmountSelector!]
  nextProtocol: StringIdSelector
  currentProtocol: StringIdSelector
}

"""Blocks in Algorand blockchain"""
type AlgorandBlocks {
  any(of: AlgorandBlocksMeasureable!): String
  count(uniq: AlgorandBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Int
  currentProtocol: String

  """Calendar date"""
  date: Date
  frac: BigInt!

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  minimum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  nextProtocol: String
  nextProtocolApprovals: BigInt
  nextProtocolSwitchOn: BigInt
  nextProtocolVoteBefore: BigInt

  """Previous block hash"""
  previousBlockHash: String!

  """Block proposer"""
  proposer(proposer: [AlgorandAddressSelector!]): Address
  rate(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AlgorandAddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  seed: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  txnRoot: String!
  upgradeApprove: Int
  upgradePropose: String
}

enum AlgorandBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Reward"""
  block_reward

  """Block Proposer"""
  proposer

  """Next protocol approvals"""
  next_protocol_approvals
}

enum AlgorandBlocksUniq {
  """Unique proposer count"""
  proposers

  """Unique date count"""
  dates
}

enum AlgorandCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction type"""
  tx_type

  """Transaction Sender"""
  tx_sender

  """Smart Contract"""
  smart_contract
}

"""Coinpath"""
type AlgorandCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Currency selector in Algorand blockchain.
  Currency is selected by asset ID. To select ALGO use ID=0
"""
input AlgorandCurrencySelector {
  """Currency is"""
  is: Int

  """Currency not"""
  not: Int

  """Currency in the list"""
  in: [Int!]

  """Currency not in the list"""
  notIn: [Int!]
}

enum AlgorandNetwork {
  """Algorand Mainnet (ALGO)"""
  algorand

  """Algorand Testnet"""
  algorand_testnet

  """Algorand Betanet"""
  algorand_betanet
}

"""Algorand smart contract"""
type AlgorandSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract byte code"""
  bytecode: String

  """Smart Contract Deassembled source code"""
  source: String
}

input AlgorandSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txSender: [AlgorandAddressSelector!]
  smartContractAddress: [AlgorandAddressSelector!]
  txType: TxTypeSelector
}

"""Smart Contract Calls"""
type AlgorandSmartContractCalls {
  any(of: AlgorandCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AlgorandAddressSelector!], smartContractAddress: [AlgorandAddressSelector!], txType: TxTypeSelector): Int

  """Calendar date"""
  date: Date

  """Fee used in transaction call"""
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AlgorandAddressSelector!], smartContractAddress: [AlgorandAddressSelector!], txType: TxTypeSelector): Float
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  minimum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  note: String
  poolerror: String

  """Smart contract being called"""
  smartContract(smartContractAddress: [AlgorandAddressSelector!]): AlgorandSmartContract

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [AlgorandAddressSelector!]): TransactionHashIndex

  """Transaction sender"""
  txSender(txSender: [AlgorandAddressSelector!]): Address

  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

input AlgorandTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AlgorandAddressSelector!]
  txIndex: TxIndexSelector
  txCurrency: [AlgorandCurrencySelector!]
  txType: TxTypeSelector
  txSubtype: TxSubtypeSelector
}

"""Transactions in Algorand blockchain"""
type AlgorandTransactions {
  any(of: AlgorandTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: AlgorandTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): Int

  """Asset related to transaction"""
  currency(txCurrency: [AlgorandCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector): Float
  firstRound: Int
  genesisHash: String
  genesisId: String

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  lastRound: Int
  maximum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  minimum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  note: String
  poolerror: String

  """Transaction sender"""
  sender(txSender: [AlgorandAddressSelector!]): Address

  """Transaction sub type"""
  subtype(txType: TxSubtypeSelector): AlgorandTxSubType

  """Transaction type"""
  type(txType: TxTypeSelector): AlgorandTxType
}

enum AlgorandTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Fee value"""
  fee

  """Transaction hash"""
  tx_hash

  """Transaction Sender"""
  tx_sender
}

enum AlgorandTransactionsUniq {
  """Unique TX senders count"""
  senders

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique currencies"""
  currencies
}

input AlgorandTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AlgorandAddressSelector!]
  txIndex: TxIndexSelector
  sender: [AlgorandAddressSelector!]
  receiver: [AlgorandAddressSelector!]
  currency: [AlgorandCurrencySelector!]
  amount: [AmountSelector!]
  txType: TxTypeSelector
  transferType: AlgorandTransferTypeSelector
}

"""Currency transfers from/to addresses in crypto currencies"""
type AlgorandTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, sender: [AlgorandAddressSelector!], receiver: [AlgorandAddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Float
  any(of: AlgorandTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AlgorandAddressSelector!], txIndex: TxIndexSelector, sender: [AlgorandAddressSelector!], receiver: [AlgorandAddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Int

  """Currency of transfer"""
  currency(currency: [AlgorandCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  firstRound: Int
  lastRound: Int
  maximum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String
  memo: String
  minimum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: [AlgorandAddressSelector!]): Address

  """Transfer sender"""
  sender(sender: [AlgorandAddressSelector!]): Address

  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex

  """Transfer Type"""
  transferType(transferType: [AlgorandTransferType!]): AlgorandTransferType

  """Transfer transaction sender"""
  txSender(txSender: [AlgorandAddressSelector!]): Address

  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

enum AlgorandTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """TX Sender"""
  tx_sender

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Currency Asset ID"""
  asset_id

  """Transaction type"""
  tx_type

  """Transfer type"""
  transfer_type
}

enum AlgorandTransferType {
  """Genesis Block"""
  genesis

  """Create Asset"""
  create

  """Send"""
  send

  """Close"""
  close

  """Reward"""
  reward

  """Asset Freeze"""
  freeze

  """Asset Unfreeze"""
  unfreeze
}

"""Select transfers by type"""
input AlgorandTransferTypeSelector {
  """Transfer Type is"""
  is: AlgorandTransferType

  """Transfer Type not"""
  not: AlgorandTransferType

  """Transfer Type in the list"""
  in: [AlgorandTransferType!]

  """Transfer Type not in the list"""
  notIn: [AlgorandTransferType!]
}

enum AlgorandTxSubType {
  """Send"""
  send

  """Close"""
  close

  """Create"""
  create

  """Asset Configuration"""
  configure

  """Asset Freeze"""
  freeze

  """Asset Unfreeze"""
  unfreeze

  """Key Reg"""
  keyreg

  """None"""
  none
}

enum AlgorandTxType {
  """Genesis Block"""
  genesis

  """Pay"""
  pay

  """Key Reg"""
  keyreg

  """Asset Configuration"""
  acfg

  """Asset Transfer"""
  axfer

  """Asset Freeze or Unfreeze"""
  afrz

  """Application Call"""
  appl
}

enum AmountAggregateFunction {
  """Maximum"""
  maximum

  """Minimum"""
  minimum

  """Sum (total)"""
  sum

  """Average"""
  average

  """Median"""
  median

  """Unique estimate fast"""
  unique

  """Unique exact"""
  uniqueExact

  """Any value"""
  any

  """Last value"""
  anyLast
}

"""Select by amount"""
input AmountSelector {
  """Amount is"""
  is: Float

  """Amount not"""
  not: Float

  """Amount in the list"""
  in: [Float!]

  """Amount not in the list"""
  notIn: [Float!]

  """Amount greater than"""
  gt: Float

  """Amount less than"""
  lt: Float

  """Amount less or equal than"""
  lteq: Float

  """Amount greater or equal than"""
  gteq: Float

  """Amount in range"""
  between: [Float!]
}

"""Selector of index of argument in call"""
input ArgumentIndexSelector {
  """Tx index is"""
  is: Int

  """Tx index not"""
  not: Int

  """Tx index in the list"""
  in: [Int!]

  """Tx index not in the list"""
  notIn: [Int!]
}

"""Argument of Smart contract method or event"""
type ArgumentName {
  """Name"""
  name: String!

  """Type"""
  type: String!
}

"""Argument name and value of smart contract call or event"""
type ArgumentNameValue {
  """Argument name"""
  argument: String!

  """Argument data type"""
  argumentType: String!

  """Sequential index of value in array ( multi-dimensional)"""
  index: String!

  """Value as String"""
  value: String!
}

"""Selector of argument for smart contract method or event"""
input ArgumentSelector {
  """Argument is"""
  is: String

  """Argument not"""
  not: String

  """Argument in the list"""
  in: [String!]

  """Argument not in the list"""
  notIn: [String!]
}

"""Selector of argument type for smart contract method or event"""
input ArgumentTypeSelector {
  """Argument type is"""
  is: String

  """Argument type not"""
  not: String

  """Argument type in the list"""
  in: [String!]

  """Argument type not in the list"""
  notIn: [String!]
}

"""Argument value of smart contract call or event"""
type ArgumentValue {
  """Value as Address"""
  address: EthereumAddressInfo

  """Value as String"""
  value: String!
}

"""Selector of value of argument for smart contract method or event"""
input ArgumentValueSelector {
  """Value is"""
  is: String

  """Value not"""
  not: String

  """Value in the list"""
  in: [String!]

  """Value not in the list"""
  notIn: [String!]
}

enum BaseCurrencyEnum {
  """Dollar"""
  USD

  """Ethereum"""
  ETH

  """Tether USDT"""
  USDT

  """Bitcoin"""
  BTC
}

"""
Represents non-fractional signed whole numeric values. Since the value may
exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar BigInt

"""Binance DEX"""
type Binance {
  """Binance DEX Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector, any: [BinanceBlockFilter!], options: QueryOptions): [BinanceBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: BinanceAddressSelector, receiver: BinanceAddressSelector, currency: [BinanceCurrencySelector!], initialAddress: BinanceAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [BinanceCoinpath!]

  """Binance DEX Network Exchange Orders"""
  orders(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!], any: [BinanceOrderFilter!], options: QueryOptions): [BinanceOrders!]

  """Binance DEX Network Trades between currencies"""
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], any: [BinanceTradeFilter!], options: QueryOptions): [BinanceTrades!]

  """Binance DEX Network Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!], any: [BinanceTransactionFilter!], options: QueryOptions): [BinanceTransactions!]

  """Binance DEX Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!], any: [BinanceTransferFilter!], options: QueryOptions): [BinanceTransfers!]
}

"""Binance Address should start with bnb and contain 42 chars."""
input BinanceAddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: String

  """Not in the list of Addresses"""
  notIn: String
}

"""Block"""
type BinanceBlock {
  any(of: BinanceBlocksMeasureable!): String

  """Block ID"""
  blockId(blockId: StringIdSelector): String
  count(uniq: BinanceBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector): Int

  """Calendar date"""
  date: Date

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String
  minimum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Validator consensus pubkey"""
  validatorConsensusPubkey(validatorConsensusPubkey: StringIdSelector): String

  """Validator fee address"""
  validatorFeeAddr(validatorFeeAddr: BinanceAddressSelector): Address

  """Validator moniker"""
  validatorMoniker(validatorMoniker: StringIdSelector): String

  """Validator operator HR address"""
  validatorOperaHrAddress(validatorOperaHrAddress: BinanceAddressSelector): Address

  """Validator operator address"""
  validatorOperatorAddress(validatorOperatorAddress: BinanceAddressSelector): Address
}

input BinanceBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: StringIdSelector
  validatorMoniker: StringIdSelector
  validatorFeeAddr: BinanceAddressSelector
  validatorOperatorAddress: BinanceAddressSelector
  validatorOperahraddress: BinanceAddressSelector
}

enum BinanceBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Validator moniker"""
  validator_moniker
}

enum BinanceBlockUniq {
  """Validator operators"""
  validator_operator_addresses

  """Validator fee addresses"""
  validator_fee_addresses

  """Unique date count"""
  dates
}

"""Coinpath"""
type BinanceCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Binance token selector by tokenId.
    Native binance token has BNB symbol.
    Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
"""
input BinanceCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

input BinanceOrderFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  orderOwner: [BinanceAddressSelector!]
  orderId: [OrderIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
  orderStatus: [OrderStatusSelector!]
  orderType: [OrderTypeSelector!]
  orderSide: [OrderSideSelector!]
  orderTimeInForce: [OrderTimeInForceSelector!]
}

"""Binance DEX Order"""
type BinanceOrders {
  any(of: BinanceOrdersMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  """Block where order transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceOrdersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Int

  """Calendar date"""
  date: Date
  maximum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String
  minimum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String

  """Order ID"""
  orderId(orderId: [OrderIdSelector!]): String

  """Order owner address"""
  orderOwner(owner: [BinanceAddressSelector!]): Address

  """Order Side"""
  orderSide(orderSide: [OrderSideSelector!]): BinanceOrderSide

  """Order Status"""
  orderStatus(orderStatus: [OrderStatusSelector!]): BinanceOrderStatus

  """Order Time In Force"""
  orderTimeInForce(orderTimeInForce: [OrderTimeInForceSelector!]): BinanceOrderTimeInForce

  """Order Type"""
  orderType(orderType: [OrderTypeSelector!]): BinanceOrderType
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  """Transaction where order created"""
  transaction(txHash: [HashSelector!]): TransactionHash
}

enum BinanceOrderSide {
  """Sell Side"""
  sell

  """Buy Side"""
  buy
}

enum BinanceOrdersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Order owner"""
  order_owner

  """Order status"""
  order_status

  """Order ID"""
  order_id

  """Order side"""
  order_side

  """Base currency"""
  base_currency

  """Quote currency"""
  quote_currency

  """Quote Amount"""
  quote_amount

  """Base Amount"""
  base_amount

  """Price"""
  price
}

enum BinanceOrderStatus {
  """Ack"""
  Ack

  """Canceled"""
  Canceled

  """Fully Fill"""
  FullyFill

  """Partial Fill"""
  PartialFill

  """Expired"""
  Expired

  """Failed Blocking"""
  FailedBlocking

  """Ioc No Fill"""
  IocNoFill

  """Ioc Expire"""
  IocExpire
}

enum BinanceOrdersUniq {
  """Unique Transactions"""
  txs

  """Unique order owners"""
  owners

  """Unique base currencies"""
  base_currencies

  """Unique quote currencies"""
  quote_currencies

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique order ID count"""
  orders
}

enum BinanceOrderTimeInForce {
  """Good Till Expiry"""
  GTE

  """Immediate Or Cancel"""
  IOC
}

enum BinanceOrderType {
  """Limit Order"""
  LimitOrder
}

input BinanceTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: [BinanceAddressSelector!]
  seller: [BinanceAddressSelector!]
  sellOrderId: [OrderIdSelector!]
  buyOrderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
}

"""Binance DEX Trades"""
type BinanceTrades {
  any(of: BinanceTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency

  """Block where trade transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Buy Order ID"""
  buyOrderId(buyOrderId: [OrderIdSelector!]): String

  """Trade buyer address"""
  buyer(buyer: [BinanceAddressSelector!]): Address
  count(uniq: BinanceTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Int

  """Calendar date"""
  date: Date
  maximum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  minimum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency

  """Sell Order ID"""
  sellOrderId(sellOrderId: [OrderIdSelector!]): String

  """Trade seller address"""
  seller(seller: [BinanceAddressSelector!]): Address

  """Trade ID"""
  tradeId(tradeId: [TradeIdSelector!]): String

  """Transaction where trade happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex
}

enum BinanceTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Buyer"""
  buyer

  """Seller"""
  seller

  """Trade ID"""
  trade_id

  """Buy Order ID"""
  buy_order_id

  """Sell Order ID"""
  sell_order_id

  """Base currency"""
  base_currency

  """Quote currency"""
  quote_currency

  """Quote Amount"""
  quote_amount

  """Base Amount"""
  base_amount

  """Price"""
  price
}

enum BinanceTradesUniq {
  """Trades"""
  trades

  """Sell Orders"""
  sell_orders

  """Buy Orders"""
  buy_orders

  """Unique Transactions"""
  txs

  """Unique buyers count"""
  buyers

  """Unique sellers count"""
  sellers

  """Unique base currencies"""
  base_currencies

  """Unique quote currencies"""
  quote_currencies

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input BinanceTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  transactionType: BinanceTransactionTypeSelector
  proposalId: StringIdSelector
  currency: [BinanceCurrencySelector!]
  transactionCode: IntIdSelector
  transactionSource: IntIdSelector
  deposit: [AmountSelector!]
}

"""Transaction"""
type BinanceTransactions {
  any(of: BinanceTransactionsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!]): Int

  """Currency issued in transaction"""
  currency(currency: [BinanceCurrencySelector!]): Currency

  """Calendar date"""
  date: Date

  """Deposit amount in transaction"""
  deposit(deposit: [AmountSelector!]): Float

  """Transaction Description"""
  description: String

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """TX index in block, 0 based"""
  index: Int

  """Transaction Log"""
  log: String
  maximum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String

  """Transaction Memo"""
  memo: String
  minimum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String

  """Proposal ID"""
  proposalId(proposalId: [IntIdSelector!]): Int

  """Transaction Type"""
  transactionCode(transactionCode: IntIdSelector): Int

  """Transaction Source"""
  transactionSource(transactionSource: IntIdSelector): TransactionSource

  """Transaction Type"""
  transactionType(transactionType: [BinanceTransactionTypeSelector!]): BinanceTransactionType
}

enum BinanceTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction Source Name"""
  transaction_source_name

  """Transaction Source Code"""
  transaction_source_code

  """Transaction Code"""
  transaction_code

  """Transaction Type"""
  transaction_type

  """Transaction Memo"""
  transaction_memo

  """Currency"""
  currency_symbol
}

enum BinanceTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique transaction source count"""
  transaction_sources
}

enum BinanceTransactionType {
  """New Order"""
  NEW_ORDER

  """Cancel Order"""
  CANCEL_ORDER

  """Transfer"""
  TRANSFER

  """Vote"""
  VOTE

  """Unfreeze Token"""
  UNFREEZE_TOKEN

  """Burn"""
  BURN

  """Freeze Token"""
  FREEZE_TOKEN

  """Submit Proposal"""
  SUBMIT_PROPOSAL

  """Listing"""
  LISTING

  """Issue"""
  ISSUE

  """Deposit"""
  DEPOSIT

  """Mint"""
  MINT

  """Time Lock"""
  TimeLock

  """Time Unlock"""
  TimeUnlock

  """Time Relock"""
  TimeRelock

  """Set Account Flag"""
  SetAccountFlag

  """Hash Timer Locked Transfer"""
  HTL_TRANSFER

  """Hash Timer Locked Deposit"""
  DEPOSIT_HTL

  """Hash Timer Locked Claim"""
  CLAIM_HTL

  """Hash Timer Locked  Refund"""
  REFUND_HTL

  """Tiny Token Issue"""
  TINY_TOKEN_ISSUE

  """Mini Token Issue"""
  MINI_TOKEN_ISSUE

  """Tiny Token Listing"""
  TINY_TOKEN_LIST

  """Mini Token Listing"""
  MINI_TOKEN_LIST

  """Tiny Token Set URI"""
  TINY_TOKEN_SET_URI

  """Mini Token Set URI"""
  MINI_TOKEN_SET_URI

  """Create sidechain validator"""
  CREATE_SIDECHAIN_VALIDATOR

  """Edit sidechain validator"""
  EDIT_SIDECHAIN_VALIDATOR

  """Delegate for sidechain"""
  SIDECHAIN_DELEGATE

  """ReDelegate for sidechain"""
  SIDECHAIN_REDELEGATE

  """Unbond from sidechain"""
  SIDECHAIN_UNBOND

  """Unjail from sidechain"""
  SIDECHAIN_UNJAIL

  """Side chain submit poroposal"""
  SIDE_SUBMIT_PROPOSAL

  """Side chain deposit"""
  SIDE_DEPOSIT

  """Side chain vote"""
  SIDE_VOTE

  """Cross chain transfer"""
  TRANSFER_OUT

  """Submit evidence"""
  BSC_SUBMIT_EVIDENCE

  """Cross chain claim"""
  CLAIM

  """Bind"""
  BIND

  """UnBind"""
  UNBIND
}

"""Select by transaction type"""
input BinanceTransactionTypeSelector {
  """Transaction Type is"""
  is: BinanceTransactionType

  """Transaction Type not"""
  not: BinanceTransactionType

  """Transaction Type in the list"""
  in: [BinanceTransactionType!]

  """Transaction Type not in the list"""
  notIn: [BinanceTransactionType!]
}

input BinanceTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  sender: [BinanceAddressSelector!]
  receiver: [BinanceAddressSelector!]
  currency: [BinanceCurrencySelector!]
  transferType: [BinanceTransferTypeSelector!]
  orderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  amount: [AmountSelector!]
  outputIndex: [OutputIndexSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type BinanceTransfers {
  """Transfer amount"""
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Float
  any(of: BinanceTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Transfer count"""
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Int

  """Currency of transfer"""
  currency(currency: [BinanceCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  maximum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String
  minimum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String

  """Order Id of trade where transfer happened"""
  orderId(orderId: [OrderIdSelector!]): String

  """Index of the output for the transfer, 0-based"""
  outputIndex(outputIndex: [OutputIndexSelector!]): Int

  """Transfer receiver"""
  receiver(receiver: [BinanceAddressSelector!]): Address

  """Transfer sender"""
  sender(sender: [BinanceAddressSelector!]): Address

  """Id of trade where transfer happened"""
  tradeId(tradeId: [TradeIdSelector!]): String

  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex

  """Transfer type"""
  transferType(transferType: [BinanceTransferTypeSelector!]): BinanceTransferType
}

enum BinanceTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol
}

enum BinanceTransferType {
  """Reward for block"""
  BLOCK_REWARD

  """Burning amount"""
  BURN

  """Claiming Hash Timer Locked Transfer"""
  CLAIM_HTL

  """Deposit for Hash Timer Locked Transfer"""
  DEPOSIT_HTL

  """Fee for DEX orders"""
  DEX_FEE

  """Genesis declaration"""
  GENESIS_DELEGATION

  """Genesis supply declaration"""
  GENESIS_SUPPLY

  """Tiny Token Issue"""
  TINY_TOKEN_ISSUE

  """Mini Token Issue"""
  MINI_TOKEN_ISSUE

  """Hash Timer Locked Transfer"""
  HTL_TRANSFER

  """Issue token"""
  ISSUE

  """Mint token"""
  MINT

  """Trade buy side"""
  TRADE_BUY

  """Trade sell side"""
  TRADE_SELL

  """Transfer"""
  TRANSFER

  """Transaction fee"""
  TX_FEE

  """Create sidechain validator"""
  CREATE_SIDECHAIN_VALIDATOR

  """Edit sidechain validator"""
  EDIT_SIDECHAIN_VALIDATOR

  """Delegate for sidechain"""
  SIDECHAIN_DELEGATE

  """ReDelegate for sidechain"""
  SIDECHAIN_REDELEGATE

  """Unbond from sidechain"""
  SIDECHAIN_UNBOND

  """Side chain submit poroposal"""
  SIDE_SUBMIT_PROPOSAL

  """Side chain deposit"""
  SIDE_DEPOSIT

  """Side chain vote"""
  SIDE_VOTE

  """Cross chain transfer"""
  TRANSFER_OUT

  """Submit evidence"""
  BSC_SUBMIT_EVIDENCE

  """Cross chain claim"""
  CLAIM

  """Bind"""
  BIND

  """UnBind"""
  UNBIND
}

"""Select transfer type(s)"""
input BinanceTransferTypeSelector {
  """Transfer type is"""
  is: BinanceTransferType

  """Transfer type not"""
  not: BinanceTransferType

  """Transfer type in the list"""
  in: [BinanceTransferType!]

  """Transfer type not in the list"""
  notIn: [BinanceTransferType!]
}

"""Bitcoin and other UTXO type blockchains"""
type Bitcoin {
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, transactionCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector, any: [BitcoinBlockFilter!], options: QueryOptions): [BitcoinBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: BitcoinCoinpathOptions): [BitcoinCoinpath!]

  """Blockchain Transaction Inputs"""
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, any: [BitcoinInputFilter!], options: QueryOptions): [BitcoinTransactionInput!]

  """Blockchain Transaction OmniTransactions"""
  omniTransactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector, any: [BitcoinOmniTransactionsFilter!], options: QueryOptions): [BitcoinOmniTransactiosn!]

  """Blockchain Transaction OmniTransfers"""
  omniTransfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector, any: [BitcoinOmniTransfersFilter!], options: QueryOptions): [BitcoinOmniTransfers!]

  """Blockchain Transaction Outputs"""
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector, any: [BitcoinOutputFilter!], options: QueryOptions): [BitcoinTransactionOutput!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, any: [BitcoinTransactionFilter!], options: QueryOptions): [BitcoinTransaction!]
}

"""Block"""
type BitcoinBlock {
  any(of: BitcoinBlocksMeasureable!): String

  """Block Hash"""
  blockHash(blockHash: StringIdSelector): String

  """Block size"""
  blockSize(blockSize: IntegerSelector): Int

  """Block stripped size"""
  blockStrippedSize(blockStrippedSize: IntegerSelector): Int

  """Block version"""
  blockVersion(blockVersion: IntegerSelector): Int

  """Block weight"""
  blockWeight(blockWeight: IntegerSelector): Int

  """Block chainwork"""
  chainwork: String
  count(uniq: BitcoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): Int

  """Calendar date"""
  date: Date

  """Difficulty"""
  difficulty(difficulty: FloatSelector): Float

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  """Block median timestamp"""
  medianTime: DateTime
  minimum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Transaction count in block"""
  transactionCount(transactionCount: IntegerSelector): Int
}

input BitcoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockWeight: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  blockStrippedSize: IntegerSelector
  difficulty: FloatSelector
}

enum BitcoinBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Tx Count"""
  transaction_count
}

enum BitcoinBlockUniq {
  """Unique date count"""
  dates
}

"""Coinpath"""
type BitcoinCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: TransactionHashIndexValues

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

enum BitcoinCoinpathMethod {
  """Tracking money flow by amounts, ignoring coins (default)"""
  moneyflow

  """Tracking coins by UTXO transactions"""
  utxo
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input BitcoinCoinpathOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]

  """Flow direction"""
  direction: FlowDirection

  """Do not include transactions below this amount"""
  minimumTxAmount: Float

  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int

  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """Invalidating cache seed"""
  seed: Int

  """Method to use coinpath"""
  coinpathMethod: BitcoinCoinpathMethod
}

input BitcoinInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputScriptType: BitcoinInputScriptTypeSelector
  inputValue: FloatSelector
}

enum BitcoinInputScriptType {
  """Input Script Signature"""
  scriptSig

  """Input Script TX Witness Script"""
  txinwitness

  """Input Script Coinbase Script"""
  coinbase
}

"""Selector of input script type"""
input BitcoinInputScriptTypeSelector {
  """Equal to Script Type"""
  is: BitcoinInputScriptType

  """Not Equal to Script Type"""
  not: BitcoinInputScriptType

  """In the list of Script Type"""
  in: [BitcoinInputScriptType!]

  """Not in the list of Script Type"""
  notIn: [BitcoinInputScriptType!]
}

enum BitcoinInputsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount

  """Address"""
  address

  """Input index"""
  input_index
}

enum BitcoinInputUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique addresses count"""
  addresses
}

enum BitcoinNetwork {
  """Bitcoin ( BTC )"""
  bitcoin

  """Bitcoin Cash ( BCH )"""
  bitcash

  """Bitcoin SV ( BSV )"""
  bitcoinsv

  """Litecoin ( LTC )"""
  litecoin

  """Dash ( DASH )"""
  dash

  """Dogecoin ( DOGE )"""
  dogecoin

  """Cardano ( ADA )"""
  cardano

  """ZCash ( ZCASH )"""
  zcash
}

input BitcoinOmniTransactionsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransactionsMeasureablse {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transactions hash"""
  tx_hash

  """Transactions index"""
  tx_index
}

enum BitcoinOmniTransactionsUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique transaction sender"""
  tx_sender
}

"""OmniTransactions"""
type BitcoinOmniTransactiosn {
  any(of: BitcoinOmniTransactionsMeasureablse!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Hash of the block"""
  blockHash(blockHash: HashSelector): String!

  """OmniTransaction s count"""
  count(uniq: BitcoinOmniTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Int

  """Calendar date"""
  date: Date

  """Transactions total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Float

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """OmniTransactions index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Invalid Reason"""
  invalidReason(invalidReason: StringSelector): String!

  """Invalid Reason"""
  json(json: StringSelector): String!
  maximum(of: BitcoinOmniTransactionsMeasureablse!, get: BitcoinOmniTransactionsMeasureablse): String
  minimum(of: BitcoinOmniTransactionsMeasureablse!, get: BitcoinOmniTransactionsMeasureablse): String

  """Transaction Sender"""
  txSender(txSender: HashSelector): String!

  """Type"""
  type(type: StringSelector): String!

  """Type Int"""
  typeInt(typeInt: IntegerSelector): Int!

  """Version"""
  valid(valid: IntegerSelector): Int!

  """Version"""
  version(version: IntegerSelector): Int!
}

"""OmniTransfers"""
type BitcoinOmniTransfers {
  any(of: BitcoinOmniTransfersMeasureablse!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Hash of the block"""
  blockHash(blockHash: HashSelector): String!

  """Transaction s count"""
  count(uniq: BitcoinOmniTransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Int

  """Currency of transfer"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Direction"""
  direction(direction: StringSelector): String

  """Divisible"""
  divisible(divisible: IntegerSelector): Int

  """Transactions total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Float

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """Transactions index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Ismine"""
  ismine(ismine: IntegerSelector): Int
  maximum(of: BitcoinOmniTransfersMeasureablse!, get: BitcoinOmniTransfersMeasureablse): String
  minimum(of: BitcoinOmniTransfersMeasureablse!, get: BitcoinOmniTransfersMeasureablse): String

  """Transfer From"""
  transferFrom(transferFrom: HashSelector): String!

  """Transfer From"""
  transferTo(transferTo: HashSelector): String!

  """Transaction Sender"""
  txSender(txSender: HashSelector): String!

  """Type"""
  type(type: StringSelector): String!

  """Type Int"""
  typeInt(typeInt: IntegerSelector): Int!

  """value"""
  value(value: FloatSelector): Float
}

input BitcoinOmniTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransfersMeasureablse {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transactions hash"""
  tx_hash

  """Transactions index"""
  tx_index
}

enum BitcoinOmniTransfersUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique transaction sender"""
  tx_sender
}

enum BitcoinOutputDirection {
  """Not defined"""
  unknown

  """Not a change return"""
  not_change

  """Change return"""
  change

  """Likely Not a change return"""
  likely_not_change

  """Likely Change return"""
  likely_change

  """Mining"""
  mining

  """Fee"""
  fee

  """Minting"""
  minting

  """Genesis"""
  genesis
}

"""A guessed direction of output"""
input BitcoinOutputDirectionSelector {
  """Equal to direction"""
  is: BitcoinOutputDirection

  """Not Equal to direction"""
  not: BitcoinOutputDirection

  """In the list of direction"""
  in: [BitcoinOutputDirection!]

  """Not in the list of direction"""
  notIn: [BitcoinOutputDirection!]
}

input BitcoinOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputScriptType: BitcoinOutputScriptTypeSelector
  outputDirection: BitcoinOutputDirectionSelector
  outputValue: FloatSelector
}

enum BitcoinOutputScriptType {
  """Output PubKey"""
  pubkey

  """Output PubKey Hash"""
  pubkeyhash

  """Output Script Hash"""
  scripthash

  """Output Witness Key Hash"""
  witness_v0_keyhash

  """Output nulldata"""
  nulldata

  """Output Witness Script Hash"""
  witness_v0_scripthash

  """Non standard output script"""
  nonstandard

  """Output Multisignature Wallet"""
  multisig

  """Output Witness Other"""
  witness_unknown
}

"""Selector of output script type"""
input BitcoinOutputScriptTypeSelector {
  """Equal to Script Type"""
  is: BitcoinOutputScriptType

  """Not Equal to Script Type"""
  not: BitcoinOutputScriptType

  """In the list of Script Type"""
  in: [BitcoinOutputScriptType!]

  """Not in the list of Script Type"""
  notIn: [BitcoinOutputScriptType!]
}

enum BitcoinOutputsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Amount"""
  amount

  """Address"""
  address

  """Output index"""
  output_index
}

enum BitcoinOutputUniq {
  """Unique transactions count"""
  transactions

  """Unique block count"""
  blocks

  """Unique date count"""
  dates

  """Unique input addresses count"""
  addresses
}

"""Transaction"""
type BitcoinTransaction {
  any(of: BitcoinTransactionsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Transaction  count"""
  count(uniq: BitcoinTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Int

  """Calendar date"""
  date: Date

  """Transaction total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float

  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!

  """Transaction index in block, 0-based"""
  index(txIndex: IntegerSelector): String!

  """Transaction total input count"""
  inputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Int

  """Transaction total input value"""
  inputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float
  maximum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String

  """Transaction total mined value"""
  minedValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float
  minimum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String

  """Transaction total output count"""
  outputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Int

  """Transaction total output value"""
  outputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector): Float

  """Transaction is coinbase"""
  txCoinbase(txCoinbase: Boolean): Boolean

  """Transaction locktime"""
  txLocktime(txLocktime: IntegerSelector): BigInt

  """Transaction size"""
  txSize(txSize: IntegerSelector): Int

  """Transaction version"""
  txVersion(txVersion: IntegerSelector): Int

  """Transaction vsize"""
  txVsize(txVsize: IntegerSelector): Int

  """Transaction weight"""
  txWeight(txWeight: IntegerSelector): Int
}

input BitcoinTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  txVsize: IntegerSelector
  txWeight: IntegerSelector
  txVersion: IntegerSelector
  txCoinbase: Boolean
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  minedValue: FloatSelector
  txLocktime: IntegerSelector
}

"""Transaction Input"""
type BitcoinTransactionInput {
  any(of: BitcoinInputsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Input count"""
  count(uniq: BitcoinInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): Int

  """Calendar date"""
  date: Date

  """Input address"""
  inputAddress(inputAddress: AddressSelector): Address

  """Input index"""
  inputIndex(inputIndex: IntegerSelector): Int

  """Input script"""
  inputScript: String

  """Input script type and attributes"""
  inputScriptType(inputScriptType: BitcoinInputScriptTypeSelector): InputScript
  maximum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String
  minimum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String

  """Output Transaction for this input"""
  outputTransaction(inOutputTxId: StringIdSelector, inOutputIndex: IntegerSelector): TransactionHashIndex

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Input value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector): Float
}

"""Transaction Output"""
type BitcoinTransactionOutput {
  any(of: BitcoinOutputsMeasureable!): String

  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Output count"""
  count(uniq: BitcoinOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Int

  """Calendar date"""
  date: Date
  maximum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String
  minimum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String

  """Output address"""
  outputAddress(outputAddress: AddressSelector): Address

  """Output guessed direction"""
  outputDirection(outputDirection: BitcoinOutputDirectionSelector): BitcoinOutputDirection

  """Output index"""
  outputIndex(outputIndex: IntegerSelector): Int

  """Output script"""
  outputScript: String

  """Output script type and attributes"""
  outputScriptType(inputScriptType: BitcoinOutputScriptTypeSelector): OutputScript
  reqSigs: Int

  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex

  """Output value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Float
}

enum BitcoinTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction index"""
  tx_index

  """Input count"""
  input_count

  """Output count"""
  output_count

  """Transaction size"""
  tx_size

  """Transaction input value"""
  input_value

  """Transaction output value"""
  output_value
}

enum BitcoinTransactionUniq {
  """Unique block count"""
  blocks

  """Unique date count"""
  dates
}

"""Block"""
type Block {
  """Block number (height) in blockchain"""
  height: Int!

  """Block timestamp"""
  timestamp: DateTime
}

"""Blockchain network"""
type BlockchainNetwork {
  """Network name"""
  network: Network!

  """Network protocol type"""
  protocol: Protocol!
}

"""BlockExtended"""
type BlockExtended {
  """Hash hex representation"""
  hash: String!

  """Block number (height) in blockchain"""
  height: Int!

  """Block timestamp"""
  timestamp: DateTime
}

"""ConfluxBlock"""
type BlockInfo {
  """Block hash"""
  hash: String

  """Block number (height) in blockchain"""
  height: Int!

  """Block timestamp"""
  timestamp: DateTime
}

"""Select block by height ( sequence number)"""
input BlockSelector {
  """Block height is"""
  is: Int

  """Block height not"""
  not: Int

  """Block height in the list"""
  in: [Int!]

  """Block height not in the list"""
  notIn: [Int!]

  """Block height greater than"""
  gt: Int

  """Block height less than"""
  lt: Int

  """Block height less or equal than"""
  lteq: Int

  """Block height greater or equal than"""
  gteq: Int

  """Block height in range"""
  between: [Int!]
}

"""Select block by height ( sequence number)"""
input BlockSelectorRange {
  """Block height less or equal than"""
  lteq: Int

  """Block height greater or equal than"""
  gteq: Int

  """Block height in range"""
  between: [Int!]
}

"""Select by boolean (sequence number)"""
input BooleanSelector {
  """Is"""
  is: Boolean

  """Is not"""
  not: Boolean
}

"""Transaction attributes in coinpath"""
type CoinpathEntry {
  """Amount involved in the flow"""
  amount: Float!

  """Block of transaction"""
  height: Int!

  """Time of transaction in ISO 8601 format"""
  timestamp: ISO8601DateTime!

  """Hash of transaction"""
  txHash: String!

  """Amount transfered in transaction"""
  txValue: Float!
}

enum CoinpathMeasureable {
  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Depth"""
  depth
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input CoinpathOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]

  """Flow direction"""
  direction: FlowDirection

  """Do not include transactions below this amount"""
  minimumTxAmount: Float

  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int

  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int

  """
  Raise error if complexity ( currently measured in transaction count ) is higher than this option
  """
  complexityLimit: Int

  """Invalidating cache seed"""
  seed: Int
}

"""Conflux Chain"""
type Conflux {
  """Basic information about address ( or smart contract )"""
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!

  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [ConfluxBlockFilter!], options: QueryOptions): [ConfluxBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]

  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!], any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector, any: [ConfluxTransactionFilter!], options: QueryOptions): [ConfluxTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

input ConfluxBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  epoch: BlockSelector
  pivot: Boolean
  blockHash: HashSelector
  referenceBlockHash: HashSelector
  miner: [EthereumAddressSelector!]
  refereeCount: [IntegerSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""Blocks in Conflux blockchain"""
type ConfluxBlocks {
  """Block is adaptive"""
  adaptive: Boolean!
  any(of: ConfluxBlocksMeasureable!): String

  """Blame"""
  blame: Int!

  """Block index in epoch"""
  blockPosition: Int!
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date

  """Epoch in blockchain"""
  epoch(height: BlockSelector): Int!

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block height in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  """Block miner"""
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String

  """Block nonce"""
  nonce: Int!

  """Parent block hash"""
  parentHash: String!

  """Block is pivot"""
  pivot: Boolean!

  """Power Quality"""
  powerQuality: BigInt!
  refereeCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Reference Block hash"""
  referenceBlockHash(referenceBlockHash: [HashSelector!]): String!
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Hash of Transaction included in block"""
  txHash(txHash: [HashSelector!]): String!
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [EthereumAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
}

enum ConfluxBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Miner"""
  miner

  """Block Referee Count"""
  referee_count

  """Block TX Count"""
  transaction_count
}

enum ConfluxNetwork {
  """Conflux Oceanus"""
  conflux_oceanus

  """Conflux Tethys"""
  conflux_tethys
}

input ConfluxTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  blockHash: HashSelector
}

"""Transactions in Conflux blockchain"""
type ConfluxTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float
  any(of: ConfluxTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(blockHash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockInfo
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int

  """Created smart contract"""
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  """Currency of amount"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Error message if any"""
  error: String
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int

  """Currency of gas"""
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String
  minimum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String

  """Transaction nonce"""
  nonce: Int

  """Transaction sender"""
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  """Success"""
  success(success: Boolean): Boolean

  """Transaction receiver"""
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

enum ConfluxTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Transaction Sender"""
  tx_sender

  """Gas value"""
  gas_value

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

enum Continent {
  """Africa"""
  Africa

  """Asia"""
  Asia

  """Europe"""
  Europe

  """North America"""
  North_America

  """Oceania"""
  Oceania

  """South America"""
  South_America

  """Antarctica"""
  Antarctica
}

"""Continent selector"""
input ContinentSelector {
  """Country code is"""
  is: Continent

  """Country code not"""
  not: Continent

  """Country code in the list"""
  in: [Continent!]

  """Country code not in the list"""
  notIn: [Continent!]
}

enum CountryCode {
  """Afghanistan"""
  AF

  """Albania"""
  AL

  """Algeria"""
  DZ

  """American Samoa"""
  AS

  """Andorra"""
  AD

  """Angola"""
  AO

  """Anguilla"""
  AI

  """Antarctica"""
  AQ

  """Antigua and Barbuda"""
  AG

  """Argentina"""
  AR

  """Armenia"""
  AM

  """Aruba"""
  AW

  """Australia"""
  AU

  """Austria"""
  AT

  """Azerbaijan"""
  AZ

  """Bahamas"""
  BS

  """Bahrain"""
  BH

  """Bangladesh"""
  BD

  """Barbados"""
  BB

  """Belarus"""
  BY

  """Belgium"""
  BE

  """Belize"""
  BZ

  """Benin"""
  BJ

  """Bermuda"""
  BM

  """Bhutan"""
  BT

  """Bolivia"""
  BO

  """Bosnia and Herzegovina"""
  BA

  """Botswana"""
  BW

  """Brazil"""
  BR

  """British Indian Ocean Territory"""
  IO

  """British Virgin Islands"""
  VG

  """Brunei"""
  BN

  """Bulgaria"""
  BG

  """Burkina Faso"""
  BF

  """Burundi"""
  BI

  """Cambodia"""
  KH

  """Cameroon"""
  CM

  """Canada"""
  CA

  """Cape Verde"""
  CV

  """Cayman Islands"""
  KY

  """Central African Republic"""
  CF

  """Chad"""
  TD

  """Chile"""
  CL

  """China"""
  CN

  """Christmas Island"""
  CX

  """Cocos Islands"""
  CC

  """Colombia"""
  CO

  """Comoros"""
  KM

  """Cook Islands"""
  CK

  """Costa Rica"""
  CR

  """Croatia"""
  HR

  """Cuba"""
  CU

  """Curacao"""
  CW

  """Cyprus"""
  CY

  """Czech Republic"""
  CZ

  """Democratic Republic of the Congo"""
  CD

  """Denmark"""
  DK

  """Djibouti"""
  DJ

  """Dominica"""
  DM

  """Dominican Republic"""
  DO

  """East Timor"""
  TL

  """Ecuador"""
  EC

  """Egypt"""
  EG

  """El Salvador"""
  SV

  """Equatorial Guinea"""
  GQ

  """Eritrea"""
  ER

  """Estonia"""
  EE

  """Ethiopia"""
  ET

  """Falkland Islands"""
  FK

  """Faroe Islands"""
  FO

  """Fiji"""
  FJ

  """Finland"""
  FI

  """France"""
  FR

  """French Polynesia"""
  PF

  """Gabon"""
  GA

  """Gambia"""
  GM

  """Georgia"""
  GE

  """Germany"""
  DE

  """Ghana"""
  GH

  """Gibraltar"""
  GI

  """Greece"""
  GR

  """Greenland"""
  GL

  """Grenada"""
  GD

  """Guam"""
  GU

  """Guatemala"""
  GT

  """Guernsey"""
  GG

  """Guinea"""
  GN

  """Guinea-Bissau"""
  GW

  """Guyana"""
  GY

  """Haiti"""
  HT

  """Honduras"""
  HN

  """Hong Kong"""
  HK

  """Hungary"""
  HU

  """Iceland"""
  IS

  """India"""
  IN

  """Indonesia"""
  ID

  """Iran"""
  IR

  """Iraq"""
  IQ

  """Ireland"""
  IE

  """Isle of Man"""
  IM

  """Israel"""
  IL

  """Italy"""
  IT

  """Ivory Coast"""
  CI

  """Jamaica"""
  JM

  """Japan"""
  JP

  """Jersey"""
  JE

  """Jordan"""
  JO

  """Kazakhstan"""
  KZ

  """Kenya"""
  KE

  """Kiribati"""
  KI

  """Kosovo"""
  XK

  """Kuwait"""
  KW

  """Kyrgyzstan"""
  KG

  """Laos"""
  LA

  """Latvia"""
  LV

  """Lebanon"""
  LB

  """Lesotho"""
  LS

  """Liberia"""
  LR

  """Libya"""
  LY

  """Liechtenstein"""
  LI

  """Lithuania"""
  LT

  """Luxembourg"""
  LU

  """Macau"""
  MO

  """Macedonia"""
  MK

  """Madagascar"""
  MG

  """Malawi"""
  MW

  """Malaysia"""
  MY

  """Maldives"""
  MV

  """Mali"""
  ML

  """Malta"""
  MT

  """Marshall Islands"""
  MH

  """Mauritania"""
  MR

  """Mauritius"""
  MU

  """Mayotte"""
  YT

  """Mexico"""
  MX

  """Micronesia"""
  FM

  """Moldova"""
  MD

  """Monaco"""
  MC

  """Mongolia"""
  MN

  """Montenegro"""
  ME

  """Montserrat"""
  MS

  """Morocco"""
  MA

  """Mozambique"""
  MZ

  """Myanmar"""
  MM

  """Namibia"""
  NA

  """Nauru"""
  NR

  """Nepal"""
  NP

  """Netherlands"""
  NL

  """Netherlands Antilles"""
  AN

  """New Caledonia"""
  NC

  """New Zealand"""
  NZ

  """Nicaragua"""
  NI

  """Niger"""
  NE

  """Nigeria"""
  NG

  """Niue"""
  NU

  """North Korea"""
  KP

  """Northern Mariana Islands"""
  MP

  """Norway"""
  NO

  """Oman"""
  OM

  """Pakistan"""
  PK

  """Palau"""
  PW

  """Palestine"""
  PS

  """Panama"""
  PA

  """Papua New Guinea"""
  PG

  """Paraguay"""
  PY

  """Peru"""
  PE

  """Philippines"""
  PH

  """Pitcairn"""
  PN

  """Poland"""
  PL

  """Portugal"""
  PT

  """Puerto Rico"""
  PR

  """Qatar"""
  QA

  """Republic of the Congo"""
  CG

  """Reunion"""
  RE

  """Romania"""
  RO

  """Russia"""
  RU

  """Rwanda"""
  RW

  """Saint Barthelemy"""
  BL

  """Saint Helena"""
  SH

  """Saint Kitts and Nevis"""
  KN

  """Saint Lucia"""
  LC

  """Saint Martin"""
  MF

  """Saint Pierre and Miquelon"""
  PM

  """Saint Vincent and the Grenadines"""
  VC

  """Samoa"""
  WS

  """San Marino"""
  SM

  """Sao Tome and Principe"""
  ST

  """Saudi Arabia"""
  SA

  """Senegal"""
  SN

  """Serbia"""
  RS

  """Seychelles"""
  SC

  """Sierra Leone"""
  SL

  """Singapore"""
  SG

  """Sint Maarten"""
  SX

  """Slovakia"""
  SK

  """Slovenia"""
  SI

  """Solomon Islands"""
  SB

  """Somalia"""
  SO

  """South Africa"""
  ZA

  """South Korea"""
  KR

  """South Sudan"""
  SS

  """Spain"""
  ES

  """Sri Lanka"""
  LK

  """Sudan"""
  SD

  """Suriname"""
  SR

  """Svalbard and Jan Mayen"""
  SJ

  """Swaziland"""
  SZ

  """Sweden"""
  SE

  """Switzerland"""
  CH

  """Syria"""
  SY

  """Taiwan"""
  TW

  """Tajikistan"""
  TJ

  """Tanzania"""
  TZ

  """Thailand"""
  TH

  """Togo"""
  TG

  """Tokelau"""
  TK

  """Tonga"""
  TO

  """Trinidad and Tobago"""
  TT

  """Tunisia"""
  TN

  """Turkey"""
  TR

  """Turkmenistan"""
  TM

  """Turks and Caicos Islands"""
  TC

  """Tuvalu"""
  TV

  """U.S. Virgin Islands"""
  VI

  """Uganda"""
  UG

  """Ukraine"""
  UA

  """United Arab Emirates"""
  AE

  """United Kingdom"""
  GB

  """United States"""
  US

  """Uruguay"""
  UY

  """Uzbekistan"""
  UZ

  """Vanuatu"""
  VU

  """Vatican"""
  VA

  """Venezuela"""
  VE

  """Vietnam"""
  VN

  """Wallis and Futuna"""
  WF

  """Western Sahara"""
  EH

  """Yemen"""
  YE

  """Zambia"""
  ZM

  """Zimbabwe"""
  ZW
}

"""Country selector by 3 digit ISO code"""
input CountrySelector {
  """Country code is"""
  is: CountryCode

  """Country code not"""
  not: CountryCode

  """Country code in the list"""
  in: [CountryCode!]

  """Country code not in the list"""
  notIn: [CountryCode!]
}

"""Country"""
type CovidCountry {
  """Area, km2"""
  areaKm2: Float

  """Continent name"""
  continent: Continent

  """Gross Domestic Product"""
  gdp: Float

  """ISO 2 letter code"""
  iso2: CountryCode

  """ISO 3 letter code"""
  iso3: String

  """ISO numeric code"""
  isoNumeric: Int

  """Location latitude"""
  latitude: Float

  """Location longitude"""
  longitude: Float

  """Country name"""
  name: String

  """Population density in thousands per km2"""
  populationPerKm2: Float

  """Population total in thousands"""
  populationTotal: Float
}

"""Facts of Covid virus development"""
type CovidFact {
  """Count of confirmed cases"""
  confirmed(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int

  """Country"""
  country(country: CountrySelector, continent: ContinentSelector): CovidCountry

  """Calendar date"""
  date: Date

  """Count of death cases"""
  deaths(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int

  """Location"""
  location: CovidLocation

  """Count of recovered cases"""
  recovered(date: DateSelector, country: CountrySelector, continent: ContinentSelector): Int
}

"""Covid History"""
type CovidHistory {
  """COVID daily facts"""
  facts(date: DateSelector, country: CountrySelector, continent: ContinentSelector, options: QueryOptions): [CovidFact!]
}

"""Geo Location"""
type CovidLocation {
  """Admin center name"""
  adminCenter: String

  """FIPS code for USA"""
  fipsCode: Int

  """Location latitude"""
  latitude: Float

  """Location longitude"""
  longitude: Float

  """Location Country name"""
  name: String

  """Location Province / State name"""
  province: String
}

"""Crypto currency ( token, coin, currency )"""
type Currency {
  """Token Smart Contract Address"""
  address: String

  """Decimals"""
  decimals: Int!

  """Currency name"""
  name: String

  """Currency symbol"""
  symbol: String!

  """Token ID"""
  tokenId: String

  """Token Type"""
  tokenType: String
}

"""Date"""
type Date {
  """String date representation with default format as YYYY-MM-DD"""
  date(format: String): String!

  """Day of month (1-31)"""
  dayOfMonth: Int!

  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!

  """Month number (1-12)"""
  month: Int!

  """
  Returns start of date interval ,
      date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
    starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
  """
  startOfInterval(format: String, interval: Int, offset: Int, unit: DateInterval!): String!

  """Year number"""
  year: Int!
}

enum DateInterval {
  """Year"""
  year

  """Month"""
  month

  """Week"""
  week

  """Day"""
  day
}

"""Selecting the date in a range, list or just date"""
input DateSelector {
  """Since date"""
  since: ISO8601DateTime

  """Till date"""
  till: ISO8601DateTime

  """Range of dates"""
  between: [ISO8601DateTime!]

  """Before date"""
  before: ISO8601DateTime

  """After date"""
  after: ISO8601DateTime

  """In dates"""
  in: [ISO8601DateTime!]

  """Not in dates"""
  notIn: [ISO8601DateTime!]

  """Date equals"""
  is: ISO8601DateTime

  """Date not equals"""
  not: ISO8601DateTime
}

"""Date and Time"""
type DateTime {
  """Day of month (1-31)"""
  dayOfMonth: Int!

  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!

  """Hour (0-23)"""
  hour: Int!

  """ISO8601 date time such as '2020-03-02T13:30:41+00:00'"""
  iso8601: ISO8601DateTime!

  """Minute (0-59)"""
  minute: Int!

  """Month number (1-12)"""
  month: Int!

  """Second (0-59)"""
  second: Int!

  """String date representation with default format as YYYY-MM-DD"""
  time(format: String): String!

  """Unix timestamp"""
  unixtime: Int!

  """Year number"""
  year: Int!
}

"""Selecting the time in a range, list or just time"""
input DateTimeSelector {
  """Since time"""
  since: ISO8601DateTime

  """Till time"""
  till: ISO8601DateTime

  """Range of time"""
  between: [ISO8601DateTime!]

  """Before time"""
  before: ISO8601DateTime

  """After time"""
  after: ISO8601DateTime

  """In times"""
  in: [ISO8601DateTime!]

  """Not in times"""
  notIn: [ISO8601DateTime!]

  """Time equals"""
  is: ISO8601DateTime

  """Time not equals"""
  not: ISO8601DateTime
}

enum DiemNetwork {
  """Diem Testnet"""
  diem_testnet

  """Libra Testnet"""
  libra_testnet
}

"""Entity"""
type Entity {
  """Entity ID"""
  id(entityId: String): String!

  """Entity number"""
  num: Int!

  """Entity realm ID"""
  realmId: Int!

  """Entity shard ID"""
  shardId: Int!

  """Entity Type"""
  type: String!
}

"""Selector of entity ID for NFT  tokens"""
input EntitySelector {
  """EntityID is"""
  is: String

  """EntityID not"""
  not: String

  """EntityID in the list"""
  in: [String!]

  """EntityID not in the list"""
  notIn: [String!]
}

enum EntityTypeEnum {
  """account"""
  account

  """contract"""
  contract

  """file"""
  file

  """topic"""
  topic

  """token"""
  token

  """schedule"""
  schedule
}

"""Select by entity type"""
input EntityTypeSelector {
  """Type is"""
  is: EntityTypeEnum

  """Type not"""
  not: EntityTypeEnum

  """Type in the list"""
  in: [EntityTypeEnum!]

  """Type not in the list"""
  notIn: [EntityTypeEnum!]
}

"""EOS Chain"""
type Eos {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [EosAddressInfo!]!

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector, any: [EosBlockFilter!], options: QueryOptions): [EosBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EosCoinpath!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean, any: [EosSmartContractCallFilter!], options: QueryOptions): [EosSmartContractCalls!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean, any: [EosTransactionFilter!], options: QueryOptions): [EosTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EosTransferFilter!], options: QueryOptions): [EosTransfers!]
}

"""Address detailed information for EOS network"""
type EosAddressInfo {
  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract if exists on the address"""
  smartContract: EosSmartContractInfo
}

input EosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: AddressSelector
}

"""Blocks in EOS blockchain"""
type EosBlocks {
  any(of: EosBlocksMeasureable!): String
  count(uniq: EosBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector): Int

  """Calendar date"""
  date: Date

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String
  minimum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String

  """Block producer"""
  producer(producer: AddressSelector): Address

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
}

enum EosBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Proposer"""
  proposer
}

enum EosBlocksUniq {
  """Unique proposer count"""
  proposers

  """Unique date count"""
  dates
}

enum EosCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Sender"""
  tx_sender

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

"""Coinpath"""
type EosCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: EosAddressInfo

  """Sender address"""
  sender: EosAddressInfo

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Currency selector in EOS blockchain.
Token identified by address of contract ( eosio.token for main EOS token ) 
"""
input EosCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Eos smart contract"""
type EosSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EosSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
  scheduled: Boolean
}

"""Smart Contract Calls"""
type EosSmartContractCalls {
  """Actors"""
  actors: String
  any(of: EosCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """Console"""
  console: String

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean): Int

  """Calendar date"""
  date: Date

  """Error Code"""
  errorCode(errorCode: IntIdSelector): Int

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  maximum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String
  minimum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String

  """Permissions"""
  permissions: String

  """Receivers"""
  receivers: String

  """True if call scheduled"""
  scheduled(scheduled: [Boolean!]): Boolean

  """Smart contract being called"""
  smartContract(smartContractAddress: AddressSelector): EosSmartContract

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

"""Blockchain smart contract"""
type EosSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  scheduled: Boolean
}

"""Transactions in EOS blockchain"""
type EosTransactions {
  any(of: EosTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EosTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int
  cpuUsageUs(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int

  """Calendar date"""
  date: Date

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  minimum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  netUsageWords(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int

  """Success"""
  scheduled(scheduled: Boolean): Boolean

  """Success"""
  success(success: Boolean): Boolean
}

enum EosTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """CPU Usage"""
  cpu_usage_us

  """Net Usage"""
  net_usage_words
}

enum EosTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input EosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: EosCurrencySelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type EosTransfers {
  """Actors"""
  actors: String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: EosTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int

  """Currency of transfer"""
  currency(currency: EosCurrencySelector): Currency

  """Calendar date"""
  date: Date

  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  maximum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  """Memo"""
  memo: String
  minimum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Transfer succeeded"""
  success(success: Boolean): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

enum EosTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Token address"""
  currency_address
}

"""Ethereum Chain"""
type Ethereum {
  """Basic information about address ( or smart contract )"""
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!

  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [EthereumBlockFilter!], options: QueryOptions): [EthereumBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]

  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!], any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], any: [EthereumTransactionFilter!], options: QueryOptions): [EthereumTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

"""Ethereum v 2.0 Baecon Chain"""
type Ethereum2 {
  """Attestations in block"""
  attestations(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Attestation!]

  """Attester Slashings"""
  attesterSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2AttesterSlashing!]

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Blocks!]

  """Attestations of blocks"""
  deposits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Deposit!]

  """Proposer Slashings"""
  proposerSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2ProposerSlashing!]

  """Voluntary Exits"""
  voluntaryExits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2VoluntaryExit!]
}

"""Attestations in Ethereum v2.0 blockchain"""
type Ethereum2Attestation {
  aggregationBits: String!
  any(of: Ethereum2AttestationsMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  """Attestation Index (0 based ) in block"""
  attestationIndex: Int!

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!

  """Committee index for attestation"""
  committeeIndex: Int!
  count(uniq: Ethereum2AttestationsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): BigInt

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String
  minimum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!

  """Sequential index of validator in committee ( 0-based)"""
  validatorInCommitteeIndex: Int!
}

"""AttestationFieldInfo for Ethereum v 2.0 network"""
type Ethereum2AttestationFieldInfo {
  epoch: Int!

  """Root Hash"""
  root: String!
}

"""AttestationInfo for Ethereum v 2.0 network"""
type Ethereum2AttestationInfo {
  beaconBlockRoot: String!
  epoch: Int!
  signature: String!
  slot: Int!
  source: Ethereum2AttestationFieldInfo!
  target: Ethereum2AttestationFieldInfo!
}

enum Ethereum2AttestationsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Committee Index"""
  committee

  """Validator index"""
  validator
}

enum Ethereum2AttestationsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique commitees"""
  committees

  """Unique validators"""
  validators

  """Unique attestations"""
  attestations

  """Unique attestation slots"""
  attestation_slots

  """Unique attestation epochs"""
  attestation_epochs
}

"""Attester Slashing in Ethereum v2.0 blockchain"""
type Ethereum2AttesterSlashing {
  any(of: Ethereum2AttesterSlashingMeasureable!): String
  attestation: Ethereum2AttestationInfo!

  """Attestation slashing sequential number"""
  attestationOrder: Int!

  """Attester Slashing Index (0 based ) in block"""
  attesterSlashingIndex: Int!

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2AttesterSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String
  minimum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!

  """Validator index in slashing sequential numbern"""
  validatorInAttestationIndex: Int!
}

enum Ethereum2AttesterSlashingMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Validator index"""
  validator
}

enum Ethereum2AttesterSlashingsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique validators"""
  validators

  """Unique slashing slots"""
  attestation_slots

  """Unique slashing epochs"""
  attestation_epochs
}

"""Blocks in Ethereum v2.0 blockchain"""
type Ethereum2Blocks {
  any(of: Ethereum2BlocksMeasureable!): String
  attestationsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  attesterSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2BlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date
  depositsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!

  """Graffiti"""
  graffiti: String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String
  minimum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  proposerSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  """Randao Reveal"""
  randaoReveal: String!

  """Block signature"""
  signature: String!

  """Block state root hash"""
  stateRoot: String!

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  voluntaryExitsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
}

enum Ethereum2BlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Miner"""
  block_proposer
}

enum Ethereum2BlocksUniq {
  """Unique proposers"""
  block_proposers

  """Unique date count"""
  dates
}

"""Deposit in Ethereum v2.0 blockchain"""
type Ethereum2Deposit {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!]): Float
  any(of: Ethereum2DepositsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2DepositsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date

  """Deposit Index (0 based ) in block"""
  depositIndex: Int!

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String
  minimum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String

  """Block parent hash"""
  parentRoot: String!
  proof: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  signature: String!

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!
}

enum Ethereum2DepositsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Validator index"""
  validator
}

enum Ethereum2DepositsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique validators"""
  validators
}

"""Eth1 attributes for Ethereum v 2.0 network"""
type Ethereum2Eth1Info {
  """Block Eth1 block hash"""
  blockHash: String!

  """Block Eth1 deposit count"""
  depositCount: Int!

  """Block Eth1 deposit root hash"""
  depositRoot: String!
}

input Ethereum2Filter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
}

enum Ethereum2Network {
  """Beacon Chain Ethereum 2.0"""
  eth2

  """Medalla Ethereum 2.0 Beacon Testnet"""
  medalla
}

"""Proposer Slashing in Ethereum v2.0 blockchain"""
type Ethereum2ProposerSlashing {
  any(of: Ethereum2ProposerSlashingMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2ProposerSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!

  """Header slashing sequential numbern"""
  headerOrder: Int!
  maximum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String
  minimum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Proposer Slashing Index (0 based ) in block"""
  proposerSlashingIndex: Int!
  slashing: Ethereum2SlashingInfo!

  """Block state root hash"""
  stateRoot: String!
}

enum Ethereum2ProposerSlashingMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Slashed Proposer"""
  proposer
}

enum Ethereum2ProposerSlashingsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique slashing slots"""
  slashing_slots

  """Unique slashing epochs"""
  slashing_epochs

  """Unique slashing proposers"""
  slashing_proposers
}

"""SlashingInfo for Ethereum v 2.0 network"""
type Ethereum2SlashingInfo {
  """Block body hash"""
  bodyRoot: String!
  epoch: Int!

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer: Ethereum2ValidatorInfo
  signature: String!
  slot: Int!

  """Block state root hash"""
  stateRoot: String!
}

"""Validator attributes for Ethereum v 2.0 network"""
type Ethereum2ValidatorInfo {
  """Validator Index as Integer"""
  index: Int!

  """Validator Pub Key"""
  pubkey: String!

  """Validator Withdrawal"""
  withdrawalCredentials: String!
}

"""Voluntary Exit in Ethereum v2.0 blockchain"""
type Ethereum2VoluntaryExit {
  any(of: Ethereum2VoluntaryExitsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2VoluntaryExitsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date

  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String
  minimum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String

  """Block parent hash"""
  parentRoot: String!

  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo

  """Signature"""
  signature: String!

  """Block state root hash"""
  stateRoot: String!

  """Validator"""
  validator: Ethereum2ValidatorInfo!
  voluntaryExitEpoch: Int!

  """Voluntary Exit Index (0 based ) in block"""
  voluntaryExitIndex: Int!
}

enum Ethereum2VoluntaryExitsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_root_hash

  """Block Proposer"""
  block_proposer

  """Validator index"""
  validator
}

enum Ethereum2VoluntaryExitsUniq {
  """Unique blocks"""
  blocks

  """Unique block proposers"""
  block_proposers

  """Unique date count"""
  dates

  """Unique validators"""
  validators
}

"""Address detailed information for Ethereum network"""
type EthereumAddressInfo {
  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfo
}

"""Blockchain address"""
type EthereumAddressInfoWithBalance {
  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String

  """DEPRECATED Current address balance"""
  balance: Float

  """DEPRECATED Balances by currencies for the address"""
  balances(date: DateSelector, time: DateTimeSelector, currency: EthereumCurrencySelector, height: BlockSelectorRange): [EthereumBalance!]

  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfoWithAttributes
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelector {
  """Equal to Address"""
  is: String

  """Not Equal to Address"""
  not: String

  """In the list of Addresses"""
  in: [String!]

  """Not in the list of Addresses"""
  notIn: [String!]
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelectorIn {
  """Equal to Address"""
  is: String

  """In the list of Addresses"""
  in: [String!]
}

input EthereumArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  reference: [EthereumAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
}

"""Arguments of Smart Contract Calls and Events"""
type EthereumArguments {
  any(of: EthereumArgumentsMeasureable!, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String

  """Method or event argument"""
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  """Counts and other metrics"""
  count(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): Int

  """Calendar date"""
  date: Date

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  maximum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String
  minimum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean): Float

  """Address value of method or event argument"""
  reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Contract method or event"""
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo

  """The Value of method or event argument"""
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum EthereumArgumentsConvertable {
  """Token symbol"""
  token_symbol

  """Token name"""
  token_name
}

enum EthereumArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Caller"""
  caller

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature"""
  signature_type

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth

  """Argument"""
  argument

  """Argument type"""
  argument_type

  """Argument value"""
  argument_value

  """Argument index"""
  argument_index
}

"""Balance in a currency"""
type EthereumBalance {
  """Currency of transfer"""
  currency: Currency

  """History of balance changes by currencies for the address"""
  history(currency: [EthereumCurrencySelector!], height: BlockSelectorRange): [EthereumBalanceChange!]
  value: Float
}

"""Change of balance in a currency"""
type EthereumBalanceChange {
  """Block number (height) in blockchain"""
  block: Int!

  """Block timestamp"""
  timestamp: ISO8601DateTime

  """Transfer amount ( positive inbound, negative outbound)"""
  transferAmount: Float
  value: Float
}

input EthereumBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [EthereumAddressSelector!]
  blockReward: [AmountSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""Blocks in Ethereum blockchain"""
type EthereumBlocks {
  any(of: EthereumBlocksMeasureable!): String
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Calendar date"""
  date: Date
  difficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String

  """Block miner"""
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String

  """Block nonce"""
  nonce: Int!

  """Parent block hash"""
  parentHash: String!
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float

  """Currency of reward"""
  rewardCurrency: Currency
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
}

enum EthereumBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Reward"""
  block_reward

  """Block Miner"""
  miner
}

enum EthereumBlocksUniq {
  """Unique miner count"""
  miners

  """Unique date count"""
  dates
}

enum EthereumCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Caller"""
  caller

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

"""Coinpath"""
type EthereumCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: EthereumAddressInfo

  """Sender address"""
  sender: EthereumAddressInfo

  """Transaction of transfer happened"""
  transaction: TransactionHashValue

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""
Currency selector in Ethereum blockchain.
  Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
  You can specify currency symbol or smart contract address. Symbols ETH/ETC are
reserved for native currencies in Ethereum mainnet and classic.
  Ethereum Smart contract address should start from 0x and contain 40 hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Ethereum DEX attributes"""
type EthereumDex {
  """Address for DEX exchange identification"""
  address: Address!

  """Full name ( name for known, Protocol for unknown )"""
  fullName: String!

  """Full name ( name for known, Protocol / address for unknown )"""
  fullNameWithId: String!

  """Name for known exchanges"""
  name: String
}

input EthereumDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  protocol: [StringSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  exchangeAddress: [EthereumAddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [EthereumCurrencySelector!]
  buyCurrency: [EthereumCurrencySelector!]
  baseCurrency: [EthereumCurrencySelector!]
  quoteCurrency: [EthereumCurrencySelector!]
  maker: [EthereumAddressSelector!]
  makerSmartContractType: [SmartContractTypeSelector!]
  taker: [EthereumAddressSelector!]
  takerSmartContractType: [SmartContractTypeSelector!]
  makerOrTaker: [EthereumAddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""Trades on DEX smart contracts"""
type EthereumDexTrades {
  """Trader (maker or taker)"""
  address(makerOrTaker: [EthereumAddressSelector!]): EthereumAddressInfo
  any(of: EthereumDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Base currency"""
  baseCurrency(baseCurrency: [EthereumCurrencySelector!]): Currency

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Maker buys this currency"""
  buyCurrency(buyCurrency: [EthereumCurrencySelector!]): Currency
  count(uniq: EthereumDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int

  """Calendar date"""
  date: Date

  """
  Identification of admin / manager / factory of smart contract, executing trades
  """
  exchange(exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!]): EthereumDex
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Trade 'maker' side"""
  maker(maker: [EthereumAddressSelector!]): EthereumAddressInfo
  maximum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  minimum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  price(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float

  """Protocol name of the smart contract"""
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Quote currency"""
  quoteCurrency(quoteCurrency: [EthereumCurrencySelector!]): Currency
  quotePrice(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float

  """Maker sells this currency"""
  sellCurrency(sellCurrency: [EthereumCurrencySelector!]): Currency

  """Side of trade ( SELL / BUY )"""
  side: TradeSide

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Trade 'taker' side"""
  taker(taker: [EthereumAddressSelector!]): EthereumAddressInfo

  """Time interval"""
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float

  """Index of trade in transaction, used to separate trades in transaction"""
  tradeIndex(tradeIndex: [StringSelector!]): String

  """Transaction of DexTrade"""
  transaction(txHash: [HashSelector!], txSender: [EthereumAddressSelector!]): EthereumTransactionInfoExtended
}

enum EthereumDexTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Buy Amount"""
  buy_amount

  """Sell Amount"""
  sell_amount

  """Price"""
  price

  """Quote Price"""
  quote_price

  """Maker"""
  maker

  """Taker"""
  taker

  """Buy Currency symbol"""
  buy_currency_symbol

  """Buy Token address"""
  buy_currency_address

  """Sell Currency symbol"""
  sell_currency_symbol

  """Sell Token address"""
  sell_currency_address
}

enum EthereumDexTradesUniq {
  """Unique TX senders count"""
  senders

  """Unique makers count"""
  makers

  """Unique makers count"""
  takers

  """Unique makers & takers count"""
  address

  """Buy currencies count"""
  buy_currency

  """Sell currencies count"""
  sell_currency

  """Base currencies count"""
  base_currency

  """Quote currencies count"""
  quote_currency

  """Unique blocks"""
  blocks

  """Unique transactions count"""
  txs

  """Unique date count"""
  dates

  """Unique smart contract count"""
  smart_contracts

  """Unique protocols count"""
  protocols
}

enum EthereumEventsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Smart Contract"""
  smart_contract

  """Smart Contract Event Name"""
  signature_name

  """Smart Contract Event Signature"""
  signature

  """Smart Contract Event Signature Hash"""
  signature_hash
}

enum EthereumNetwork {
  """Ethereum Mainnet"""
  ethereum

  """Ethereum Classic"""
  ethclassic

  """Ethereum Classic ( no reorg from block 10904146)"""
  ethclassic_reorg

  """Celo Alfajores Testnet"""
  celo_alfajores

  """Celo Baklava Testnet"""
  celo_baklava

  """Celo RC1"""
  celo_rc1

  """Binance Smart Chain Mainnet"""
  bsc

  """Binance Smart Chain Testnet"""
  bsc_testnet

  """Goerli Ethereum Testnet"""
  goerli

  """Matic (Polygon) Mainnet"""
  matic
}

"""Ethereum smart contract"""
type EthereumSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EthereumSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: SmartContractTypeSelector
  external: Boolean
  success: [Boolean!]
}

"""Smart Contract Calls"""
type EthereumSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Float
  any(of: EthereumCallsMeasureable!): String

  """Call arguments"""
  arguments: [ArgumentNameValue!]

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """
  Caller of the method invocation ( tx sender or another smart contract )
  """
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Int

  """Calendar date"""
  date: Date

  """
  External call executed explicitly by tx sender. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean

  """
  Gas used for transaction in external call, or by methd in internal call
  """
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: [Boolean!]): Float
  maximum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String
  minimum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

"""Smart Contract Events"""
type EthereumSmartContractEvent {
  any(of: EthereumEventsMeasureable!): String

  """Event arguments"""
  arguments: [ArgumentNameValue!]

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector): Int

  """Calendar date"""
  date: Date

  """Event index"""
  eventIndex: String
  maximum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String
  minimum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String

  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract

  """Contract event logged"""
  smartContractEvent(smartContractEvent: EventSelector): Event

  """Transaction where event happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

input EthereumSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  smartContractType: SmartContractTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractEvent: EventSelector
}

"""Blockchain smart contract"""
type EthereumSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Blockchain smart contract"""
type EthereumSmartContractInfoWithAttributes {
  """Attributes from readonly methods"""
  attributes: [SmartContractReadonlyAttribute!]

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input EthereumTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  gasValue: [AmountSelector!]
}

"""Blockchain transaction info"""
type EthereumTransactionInfo {
  """Gas consumed"""
  gas: Int!

  """Gas price in Gwei"""
  gasPrice: Float!

  """Gas value cost"""
  gasValue: Float!

  """Hash hex representation"""
  hash: String!

  """Transaction from address"""
  txFrom: EthereumAddressInfo!
}

"""Blockchain Transaction Extended info"""
type EthereumTransactionInfoExtended {
  """Gas consumed"""
  gas: Int!

  """Gas price in Gwei"""
  gasPrice: Float!

  """Gas value cost"""
  gasValue: Float!

  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0 based"""
  index: Int

  """Transaction nonce"""
  nonce: Int

  """Transaction receiver"""
  to: EthereumAddressInfo

  """Transaction from address"""
  txFrom: EthereumAddressInfo!
}

"""Transactions in Ethereum blockchain"""
type EthereumTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float
  any(of: EthereumTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Int

  """Created smart contract"""
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo

  """Currency of amount"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Error message if any"""
  error: String
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float

  """Currency of gas"""
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency

  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!]): Float

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String
  minimum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String

  """Transaction nonce"""
  nonce: Int

  """Transaction sender"""
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo

  """Success"""
  success(success: Boolean): Boolean

  """Transaction receiver"""
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

enum EthereumTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Transaction Sender"""
  tx_sender

  """Gas value"""
  gas_value

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

enum EthereumTransactionsUniq {
  """Unique TX senders count"""
  senders

  """Unique TX receivers count"""
  receivers

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input EthereumTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  entityId: EntitySelector
  sender: [EthereumAddressSelector!]
  receiver: [EthereumAddressSelector!]
  currency: [EthereumCurrencySelector!]
  external: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type EthereumTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!]): Float
  any(of: EthereumTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!]): Int

  """Currency of transfer"""
  currency(currency: [EthereumCurrencySelector!]): Currency

  """Calendar date"""
  date: Date

  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, amount: [AmountSelector!]): Float
  maximum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String
  minimum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: [EthereumAddressSelector!]): EthereumAddressInfo

  """Transfer sender"""
  sender(sender: [EthereumAddressSelector!]): EthereumAddressInfo

  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

enum EthereumTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Token address"""
  currency_address

  """Entity ID"""
  entity_id
}

"""Smart contract event"""
type Event {
  """Name"""
  name: String

  """Signature"""
  signature: String

  """Signature Hash"""
  signatureHash: String!
}

"""
Smart contract event. In selector you can use the name, signature or hex hash
"""
input EventSelector {
  """Event signature is"""
  is: String

  """Event signature not"""
  not: String

  """Event signature in the list"""
  in: [String!]

  """Event signature not in the list"""
  notIn: [String!]
}

"""Solana External Action"""
type ExternalAction {
  name: String!
}

"""Filecoin"""
type Filecoin {
  """Filecoin Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector, any: [FilecoinBlockFilter!], options: QueryOptions): [FilecoinBlock!]

  """Filecoin Network Calls"""
  calls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector, any: [FilecoinCallFilter!], options: QueryOptions): [FilecoinCalls!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [FilecoinCoinpath!]

  """Filecoin Network Messages ( blocks, transfers, ... )"""
  messages(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector, any: [FilecoinMessageFilter!], options: QueryOptions): [FilecoinMessages!]

  """Filecoin Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector, any: [FilecoinTransferFilter!], options: QueryOptions): [FilecoinTransfers!]
}

"""Block"""
type FilecoinBlock {
  any(of: FilecoinBlocksMeasureable!): String
  blockSig: NameWithId
  blsAggregate: NameWithId
  count(uniq: FilecoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int

  """Calendar date"""
  date: Date
  electionProof: String
  forkSignalling: BigInt

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block round in blockchain"""
  height(height: BlockSelector): Int!

  """Block index on height"""
  index(blockIndex: IntegerSelector): Int
  maximum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  messageCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  messages: String

  """Miner"""
  miner(miner: AddressSelector): Address
  minerTips(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  minimum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  parentMessageReceipts: String
  parentStateRoot: String
  parentWeight: BigInt
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  ticket: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalReward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  winCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  wincount: Int
}

input FilecoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [AddressSelector!]
  blockIndex: IntegerSelector
}

enum FilecoinBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Miner"""
  miner
}

enum FilecoinBlockUniq {
  """Miner"""
  miners

  """Unique date count"""
  dates

  """Unique block height count"""
  heights

  """Unique block count"""
  blocks
}

input FilecoinCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  messageMethod: IntegerSelector
}

"""Calls in Filecoin blockchain"""
type FilecoinCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Float
  any(of: FilecoinCallsMeasureable!): String

  """Block where transfer Message is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Call hash"""
  callHash: String

  """Call hash"""
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Int

  """Calendar date"""
  date: Date
  exitCode: BigInt
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String

  """Message Method"""
  messageMethod(messageMethod: IntegerSelector): NameWithId

  """Method"""
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minimum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String
  nonce: BigInt

  """Message receiver"""
  receiver(receiver: AddressSelector): AddressWithAccount
  returnValue: String

  """Message sender"""
  sender(sender: AddressSelector): AddressWithAccount

  """Success"""
  success(success: Boolean): Boolean
}

enum FilecoinCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Message hash"""
  message_hash

  """Amount"""
  amount

  """Gas value"""
  gas_value

  """Gas limit"""
  gas_limit

  """Gas used"""
  gas
}

"""Coinpath"""
type FilecoinCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Message of transfer happened"""
  message: TransactionHashValue
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address
}

input FilecoinMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  index: IntegerSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  success: Boolean
  amount: AmountSelector
}

"""Messages in Filecoin blockchain"""
type FilecoinMessages {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  any(of: FilecoinMessagesMeasureable!): String
  baseFeeBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float

  """Block where transfer Message is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  burned(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int

  """Calendar date"""
  date: Date
  exitCode: BigInt
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float

  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String

  """Method"""
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minerPenalty(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minerTip(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minimum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String
  nonce: BigInt
  overEstimationBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float

  """Message receiver"""
  receiver(receiver: AddressSelector): AddressWithAccount
  refund(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  returnValue: String

  """Message sender"""
  sender(sender: AddressSelector): AddressWithAccount
  signature: String
  signatureType: String

  """Signed Message hash"""
  signedHash: String

  """Success"""
  success(success: Boolean): Boolean
  totalCost(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
}

enum FilecoinMessagesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Message hash"""
  message_hash

  """Amount"""
  amount

  """Gas value"""
  gas_value

  """Gas limit"""
  gas_limit

  """Gas used"""
  gas
}

enum FilecoinMessagesUniq {
  """Unique block heights"""
  blocks

  """Unique date count"""
  dates

  """Unique Message senders"""
  senders

  """Unique Message receivers"""
  receivers
}

"""Filecoin Mined Block"""
type FilecoinMinedBlock {
  """Hash"""
  hash: String

  """Index on height"""
  index: Int

  """Miner"""
  miner: Address
}

enum FilecoinNetwork {
  """Filecoin Mainnet"""
  filecoin
}

input FilecoinTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  transferType: TransferTypeSelector
  messageMethod: IntegerSelector
}

"""Transfers in Filecoin blockchain"""
type FilecoinTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Float
  any(of: FilecoinTransfersMeasureable!): String

  """Block where transfer Transfer is included"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended

  """Call hash"""
  callHash: String

  """Call hash"""
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Int

  """Currency of transfer"""
  currency: Currency

  """Calendar date"""
  date: Date

  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String

  """Message Method"""
  messageMethod(messageMethod: IntegerSelector): NameWithId

  """Method"""
  method(method: IntegerSelector): NameWithId
  minimum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Transfer timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Type of transfer"""
  transferType(transferType: TransferTypeSelector): FilecoinTransferType
}

enum FilecoinTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Transfer hash"""
  tx_hash

  """Value"""
  value

  """Gas value"""
  gas_value

  """Gas limit"""
  gas_limit

  """Gas used"""
  gas
}

enum FilecoinTransferType {
  """Send (transfer)"""
  send

  """Miner Tip"""
  miner

  """Reward"""
  reward

  """Burn"""
  burn

  """Rebalance"""
  rebalance

  """Genesis"""
  genesis
}

"""Select by number"""
input FloatSelector {
  """is"""
  is: Float

  """not"""
  not: Float

  """in the list"""
  in: [Float!]

  """not in the list"""
  notIn: [Float!]

  """greater than"""
  gt: Float

  """less than"""
  lt: Float

  """less or equal than"""
  lteq: Float

  """greater or equal than"""
  gteq: Float

  """in range"""
  between: [Float!]
}

enum FlowDirection {
  """Inbound transfers"""
  inbound

  """Outbound transfers"""
  outbound
}

"""Select by hash"""
input HashSelector {
  """Hash is"""
  is: String

  """Hash not"""
  not: String

  """Hash in the list"""
  in: [String!]

  """Hash not in the list"""
  notIn: [String!]
}

"""Hedera Chain"""
type Hedera {
  """Blockchain Arguments"""
  arguments(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean, any: [HederaArgumentFilter!], options: QueryOptions): [HederaArgument!]

  """Blockhain Calls"""
  calls(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, callInput: HashSelector, callResult: HashSelector, success: Boolean, any: [HederaCallFilter!], options: QueryOptions): [HederaCall!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [HederaCoinpath!]

  """Blockhain Inputs"""
  inputs(date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!], any: [HederaInputFilter!], options: QueryOptions): [HederaInput!]

  """Blockhain Messages"""
  messages(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaMessageFilter!], options: QueryOptions): [HederaMessage!]

  """Blockchain Outputs"""
  outputs(date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaOutputFilter!], options: QueryOptions): [HederaOutput!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaTransactionFilter!], options: QueryOptions): [HederaTransaction!]
}

"""Blockchain accounts"""
type HederaAccount {
  """Account"""
  account: String!
}

"""Arguments in Hedera blockchain"""
type HederaArgument {
  any(of: HederaArgumentsMeasureable!): String

  """Argument type"""
  argtype: String

  """Argument"""
  argument: String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaArgumentsUniq): Int

  """Calendar date"""
  date: Date

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maximum(of: HederaArgumentsMeasureable!, get: HederaArgumentsMeasureable): String
  memo: String
  minimum(of: HederaArgumentsMeasureable!, get: HederaArgumentsMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Smart contract"""
  smartContractEntity: Account

  """Success"""
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp

  """Value"""
  value: String
}

input HederaArgumentFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  success: Boolean
}

enum HederaArgumentsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaArgumentsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique node account"""
  smart_contract_entity

  """Unique initial balance"""
  initial_balance
}

"""Calls in Hedera blockchain"""
type HederaCall {
  any(of: HederaCallsMeasureable!): String

  """Call input"""
  callInput(callInput: HashSelector): String

  """Call input"""
  callResult(callResult: HashSelector): String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaCallsUniq): Int

  """Calendar date"""
  date: Date

  """Currency of transfer"""
  feeCurrency: Currency
  gas(calculate: AmountAggregateFunction, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, callInput: HashSelector, callResult: HashSelector, success: Boolean): Int
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maximum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String
  memo: String
  minimum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Smart contract"""
  smartContractEntity: Account

  """Success"""
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaCallFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  callInput: HashSelector
  callResult: HashSelector
  success: Boolean
}

enum HederaCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaCallsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique node account"""
  smart_contract_entity

  """Unique initial balance"""
  initial_balance
}

"""Coinpath"""
type HederaCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Currency selector in Hedera blockchain."""
input HederaCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Inputs in Hedera blockchain"""
type HederaInput {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  any(of: HederaInputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaInputsUniq): Int

  """Currency of transfer"""
  currency(currency: HederaCurrencySelector): Currency

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String
  memo: String
  minimum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar time"""
  time: DateTime
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int

  """Transfer Account"""
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaInputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
  amount: [AmountSelector!]
}

enum HederaInputMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee

  """Amount"""
  amount
}

enum HederaInputsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

"""Messages in Hedera blockchain"""
type HederaMessage {
  any(of: HederaMessageMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaMessagesUniq): Int

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String
  memo: String
  message: String
  minimum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar date time"""
  time: DateTime

  """Transaction running hash"""
  topicRunningHash(topicRunningHash: StringSelector): String

  """Transaction running hash"""
  topicSequenceNumber(topicSequenceNumber: HashSelector): String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaMessageFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  transactionRunningHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaMessageMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaMessagesUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

enum HederaNetwork {
  """The Hedera mainnet"""
  hedera

  """The Hedera testnets"""
  hedera_testnets
}

"""Outputs in Hedera blockchain"""
type HederaOutput {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  any(of: HederaOutputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaOutputUniq): Int

  """Currency of transfer"""
  currency(currency: HederaCurrencySelector): Currency

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String
  memo: String
  minimum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar time"""
  time: DateTime
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int

  """Transfer Account"""
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaOutputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaOutputMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee

  """Amount"""
  amount
}

enum HederaOutputUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique Transfer entity"""
  transfer_entity

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

"""Transactions in Hedera blockchain"""
type HederaTransaction {
  any(of: HederaTransactionMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaTransactionsUniq): Int

  """Calendar date"""
  date: Date

  """Entity"""
  entity(entityType: EntityTypeSelector): Entity

  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaTransactionMeasureable!, get: HederaTransactionMeasureable): String
  memo: String
  minimum(of: HederaTransactionMeasureable!, get: HederaTransactionMeasureable): String

  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account

  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account

  """Transaction result"""
  result(result: HashSelector): TransactionResult

  """Success"""
  success(success: Boolean): Boolean

  """Calendar time"""
  time: DateTime
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float

  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String

  """Transaction Type"""
  transactionType: String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaTransactionFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaTransactionMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Valid start"""
  valid_start

  """Valid duration"""
  valid_duration

  """Transaction Hash"""
  transaction_hash

  """Max Fee"""
  max_fee

  """Charged Fee"""
  transaction_fee
}

enum HederaTransactionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique consensus time"""
  consensus_times

  """Unique transaction type"""
  transaction_type

  """Unique payer account"""
  payer_account

  """Unique node account"""
  node_account

  """Unique entity id"""
  entity_id

  """Unique entity type"""
  entity_type

  """Unique initial balance"""
  initial_balance
}

"""Input Script Type of UTXO transaction input"""
type InputScript {
  """Script annotation"""
  annotation: String

  """Long script pattern"""
  pattern: String!

  """Short script pattern"""
  shortPattern: String!

  """Simple script pattern"""
  simplePattern: String!

  """Script type"""
  type: BitcoinInputScriptType
}

"""Select limited upper number"""
input IntegerLimitedSelector {
  """is"""
  is: Int

  """in the list"""
  in: [Int!]

  """less than"""
  lt: Int

  """less or equal than"""
  lteq: Int

  """in range"""
  between: [Int!]
}

"""Select by number"""
input IntegerSelector {
  """is"""
  is: Int

  """not"""
  not: Int

  """in the list"""
  in: [Int!]

  """not in the list"""
  notIn: [Int!]

  """greater than"""
  gt: Int

  """less than"""
  lt: Int

  """less or equal than"""
  lteq: Int

  """greater or equal than"""
  gteq: Int

  """in range"""
  between: [Int!]
}

"""Select by ID"""
input IntIdSelector {
  """ID is"""
  is: Int

  """ID not"""
  not: Int

  """ID in the list"""
  in: [Int!]

  """ID not in the list"""
  notIn: [Int!]

  """ID greater than"""
  gt: Int

  """ID less than"""
  lt: Int

  """ID less or equal than"""
  lteq: Int

  """ID greater or equal than"""
  gteq: Int

  """ID in range"""
  between: [Int!]
}

"""An ISO 8601-encoded date"""
scalar ISO8601Date

"""An ISO 8601-encoded datetime"""
scalar ISO8601DateTime

"""Libra"""
type Libra {
  """Libra Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector, any: [LibraBlockFilter!], options: QueryOptions): [LibraBlock!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [LibraCoinpath!]

  """Libra Network Currency Minting"""
  mints(date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!], any: [LibraMintFilter!], options: QueryOptions): [LibraMints!]

  """Libra Network Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector, any: [LibraTransactionFilter!], options: QueryOptions): [LibraTransactions!]

  """Libra Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector, any: [LibraTransferFilter!], options: QueryOptions): [LibraTransfers!]
}

"""Block"""
type LibraBlock {
  any(of: LibraBlocksMeasureable!): String
  count(uniq: LibraBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): BigInt

  """Calendar date"""
  date: Date
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): Float

  """Block round in blockchain"""
  height(height: BlockSelector): Int!

  """Key"""
  key: String
  maximum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  """Metadata"""
  metadata(metadata: StringSelector): String
  minimum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String

  """Proposer"""
  proposer(proposer: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Status Name"""
  statusName: String

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Version of transaction for this block"""
  version(version: IntegerSelector): Int!

  """Version hash of transaction for this block"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

input LibraBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  proposer: [AddressSelector!]
  metadata: StringSelector
}

enum LibraBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block round"""
  block

  """Version"""
  version

  """Proposer"""
  proposer

  """Gas Used"""
  gas_used
}

enum LibraBlockUniq {
  """Proposer"""
  proposer

  """Unique date count"""
  dates
}

"""Coinpath"""
type LibraCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: LibraCoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: BigInt

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String
  minimum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String

  """Receiver address"""
  receiver: Address

  """Sender address"""
  sender: Address

  """Transaction of transfer happened"""
  transaction: LibraTransactionValue
}

enum LibraCoinpathMeasureable {
  """Time"""
  time

  """Block"""
  block

  """Version"""
  version

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Depth"""
  depth
}

"""
Currency selector in Libra blockchain.
Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
Use name of currency for selection
"""
input LibraCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

input LibraMintFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  version: IntegerSelector
  minter: AddressSelector
  currency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
}

"""Mints in Libra blockchain"""
type LibraMints {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): Float
  any(of: LibraMintsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraMintsUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): BigInt

  """Currency of transfer"""
  currency(currency: [LibraCurrencySelector!]): Currency

  """Calendar date"""
  date: Date
  maximum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String
  minimum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String

  """Minter"""
  minter(sender: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Status Name"""
  statusName: String

  """Success"""
  success(success: Boolean): Boolean

  """Mint timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!

  """Version hash of blockchain for this transaction"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

enum LibraMintsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Version"""
  version

  """Mint version hash"""
  version_hash

  """Amount"""
  amount

  """Minter"""
  minter

  """Currency symbol"""
  currency_symbol
}

enum LibraMintsUniq {
  """Unique blocks"""
  blocks

  """Unique versions"""
  versions

  """Unique date count"""
  dates

  """Unique minters"""
  minters

  """Unique currencies"""
  currencies
}

input LibraTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  scriptType: ScriptTypeSelectorSelector
  success: Boolean
  gasCurrency: [LibraCurrencySelector!]
  scriptHash: StringSelector
}

"""Transactions in Libra blockchain"""
type LibraTransactions {
  any(of: LibraTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): BigInt

  """Calendar date"""
  date: Date

  """Expiration Time"""
  expirationTime: DateTime
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Int

  """Currency of gas"""
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  """Gas unit price"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float

  """Max gas amount"""
  maxGasAmount: Int
  maximum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String
  minimum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String

  """Public key"""
  publicKey: String

  """Script Hash"""
  scriptHash(scriptHash: StringSelector): String

  """Script Type"""
  scriptType: ScriptTypeSelectorSelector

  """Transaction sender"""
  sender(txSender: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Signature"""
  signature: String

  """Signature scheme"""
  signatureScheme: String

  """Status Name"""
  statusName: String

  """Success"""
  success(success: Boolean): Boolean

  """Transaction timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!

  """Version hash of blockchain for this transaction"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

enum LibraTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Version"""
  version

  """Transaction Sender"""
  tx_sender

  """Script Hash"""
  script_hash

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

enum LibraTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique versions"""
  versions

  """Unique date count"""
  dates

  """Unique transaction senders"""
  senders

  """Unique transaction script hashes"""
  scripts
}

"""Blockchain transaction with value"""
type LibraTransactionValue {
  """Transaction value"""
  value: Float!

  """Transaction version"""
  version: Int!
}

input LibraTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: [LibraCurrencySelector!]
  gasCurrency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
  scriptType: ScriptTypeSelectorSelector
  scriptHash: StringSelector
}

"""Transfers in Libra blockchain"""
type LibraTransfers {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float
  any(of: LibraTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): BigInt

  """Currency of transfer"""
  currency(currency: [LibraCurrencySelector!]): Currency

  """Calendar date"""
  date: Date

  """Expiration Time"""
  expirationTime: DateTime
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Int

  """Currency of gas"""
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency

  """Gas price"""
  gasPrice: Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float

  """Max gas amount"""
  maxGasAmount: Int
  maximum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String
  minimum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String

  """Public key"""
  publicKey: String

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Script Hash"""
  scriptHash(scriptHash: StringSelector): String

  """Script Type"""
  scriptType: ScriptTypeSelectorSelector

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Sequence number"""
  sequenceNumber: Int

  """Signature"""
  signature: String

  """Signature scheme"""
  signatureScheme: String

  """Status Name"""
  statusName: String

  """Success"""
  success(success: Boolean): Boolean

  """Transfer timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """Transaction sender"""
  txSender(txSender: AddressSelector): Address

  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!

  """Version hash of blockchain for this transaction"""
  versionHash: String!

  """VM Status"""
  vmStatus: Int
}

enum LibraTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  height

  """Version"""
  version

  """Version hash"""
  version_hash

  """Amount"""
  amount

  """Transfer Sender"""
  tx_sender

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Script Hash"""
  script_hash

  """Currency symbol"""
  currency_symbol

  """Gas value"""
  gas_value

  """Gas price"""
  gas_price

  """Gas used"""
  gas
}

"""Limit by definition"""
input LimitByOption {
  """Take limit for each combination of the field"""
  each: String!

  """Limit number of results"""
  limit: Int

  """Offset of results, starting from 0"""
  offset: Int
}

"""Solana Log"""
type Log {
  consumed: BigInt!
  instruction: String!
  logs: String!
  result: String!
  totalGas: BigInt!
}

"""Smart contract method"""
type Method {
  """Name"""
  name: String

  """Signature"""
  signature: String

  """Signature Hash"""
  signatureHash: String!
}

"""
Smart contract method. In selector you can use the name, signature or hex hash
"""
input MethodSelector {
  """Method signature is"""
  is: String

  """Method signature not"""
  not: String

  """Method signature in the list"""
  in: [String!]

  """Method signature not in the list"""
  notIn: [String!]
}

"""Name with an identifier"""
type NameWithId {
  """ID"""
  id: Int

  """Name"""
  name: String
}

enum Network {
  """Ethereum Mainnet"""
  ethereum

  """Ethereum Classic"""
  ethclassic

  """Ethereum Classic ( no reorg from block 10904146)"""
  ethclassic_reorg

  """Binance DEX"""
  binance

  """Celo Alfajores Testnet"""
  celo_alfajores

  """Celo Baklava Testnet"""
  celo_baklava

  """Celo RC1"""
  celo_rc1

  """Bitcoin ( BTC )"""
  bitcoin

  """Bitcoin Cash ( BCH )"""
  bitcash

  """Bitcoin SV ( BSV )"""
  bitcoinsv

  """Litecoin ( LTC )"""
  litecoin

  """Dash ( DASH )"""
  dash

  """Dogecoin ( DOGE )"""
  dogecoin

  """Cardano ( ADA )"""
  cardano

  """Zcash ( ZEC )"""
  zcash

  """Algorand Mainnet (ALGO)"""
  algorand

  """Algorand Testnet"""
  algorand_testnet

  """Algorand Betanet"""
  algorand_betanet

  """Conflux Oceanus"""
  conflux_oceanus

  """Conflux Tethys"""
  conflux_tethys

  """Libra Testnet"""
  libra_testnet

  """Diem Testnet"""
  diem_testnet

  """EOS Mainnet"""
  eos

  """Tron Mainnet"""
  tron

  """Binance Smart Chain Mainnet"""
  bsc

  """Binance Smart Chain Testnet"""
  bsc_testnet

  """Goerli Ethereum Testnet"""
  goerli

  """Beacon Chain Ethereum 2.0"""
  eth2

  """Medalla Ethereum 2.0 Beacon Testnet"""
  medalla

  """Filecoin Mainnet"""
  filecoin

  """Hedera Hashgraph"""
  hedera

  """Solana Mainnet"""
  solana

  """Matic (Polygon) Mainnet"""
  matic
}

"""Offchain Data"""
type Offchain {
  """Historical COVID data"""
  covid: CovidHistory
}

"""Select order by ID"""
input OrderIdSelector {
  """Order ID is"""
  is: String

  """Order ID not"""
  not: String

  """Order ID in the list"""
  in: [String!]

  """Order ID not in the list"""
  notIn: [String!]
}

"""Select by order side"""
input OrderSideSelector {
  """Order Side is"""
  is: BinanceOrderSide

  """Order Side not"""
  not: BinanceOrderSide

  """Order Side in the list"""
  in: [BinanceOrderSide!]

  """Order Side not in the list"""
  notIn: [BinanceOrderSide!]
}

"""Select by order status"""
input OrderStatusSelector {
  """Order Status is"""
  is: BinanceOrderStatus

  """Order Status not"""
  not: BinanceOrderStatus

  """Order Status in the list"""
  in: [BinanceOrderStatus!]

  """Order Status not in the list"""
  notIn: [BinanceOrderStatus!]
}

"""Select by order time in force"""
input OrderTimeInForceSelector {
  """Order TimeInForce is"""
  is: BinanceOrderTimeInForce

  """Order TimeInForce not"""
  not: BinanceOrderTimeInForce

  """Order TimeInForce in the list"""
  in: [BinanceOrderTimeInForce!]

  """Order TimeInForce not in the list"""
  notIn: [BinanceOrderTimeInForce!]
}

"""Select by order type"""
input OrderTypeSelector {
  """Order Type is"""
  is: BinanceOrderType

  """Order Type not"""
  not: BinanceOrderType

  """Order Type in the list"""
  in: [BinanceOrderType!]

  """Order Type not in the list"""
  notIn: [BinanceOrderType!]
}

"""Select by output index ( o based )"""
input OutputIndexSelector {
  """Output index is"""
  is: Int

  """Output index not"""
  not: Int

  """Output index in the list"""
  in: [Int!]

  """Output index not in the list"""
  notIn: [Int!]

  """Output index greater than"""
  gt: Int

  """Output index less than"""
  lt: Int

  """Output index less or equal than"""
  lteq: Int

  """Output index greater or equal than"""
  gteq: Int

  """Output index in range"""
  between: [Int!]
}

"""Output Script Type of UTXO transaction output"""
type OutputScript {
  """Script annotation"""
  annotation: String

  """Long script pattern"""
  pattern: String!

  """Short script pattern"""
  short: String!

  """Simple script pattern"""
  simplePattern: String!

  """Script type"""
  type: BitcoinOutputScriptType
}

enum PriceAggregateFunction {
  """Maximum"""
  maximum

  """Minimum"""
  minimum

  """Aggregated over interval"""
  sum

  """Average"""
  average

  """Median"""
  median

  """Any value"""
  any

  """Last value"""
  anyLast
}

"""Solana Program"""
type Program {
  id: String!
  name: String!
  parsedName: String!
}

enum Protocol {
  """Ethereum"""
  ethereum

  """Binance DEX"""
  binance

  """Bitcoin"""
  bitcoin

  """Algorand"""
  algorand

  """Libra"""
  libra

  """EOS"""
  eos

  """Tron"""
  tron

  """Filecoin"""
  filecoin

  """Hedera Hashgraph"""
  hedera

  """Solana"""
  solana
}

"""Blockchain Unified GraphQL API"""
type Query {
  """Algorand Chains Dataset"""
  algorand(network: AlgorandNetwork): Algorand

  """Binance DEX Chain Dataset"""
  binance: Binance

  """Bitcoin and other UTXO Chains Dataset"""
  bitcoin(network: BitcoinNetwork): Bitcoin

  """Conflux Chains Dataset"""
  conflux(network: ConfluxNetwork): Conflux

  """Diem ( former Libra ) Testnet Dataset"""
  diem(network: DiemNetwork): Libra

  """EOS Mainnet Dataset"""
  eos: Eos

  """Ethereum Mainnet / Classic Chain Datasets"""
  ethereum(network: EthereumNetwork): Ethereum

  """Ethereum v2.0 Beacon Chain Datasets"""
  ethereum2(network: Ethereum2Network): Ethereum2

  """Filecoin Dataset"""
  filecoin(network: FilecoinNetwork): Filecoin

  """Hedera Dataset"""
  hedera(network: HederaNetwork): Hedera

  """Offchain data"""
  offchain: Offchain

  """Search by query string"""
  search(string: String!, limit: Int, offset: Int, network: Network): [Result!]

  """Solana Dataset"""
  solana(network: SolanaNetwork): Solana

  """Tron Mainnet Dataset"""
  tron: Tron
}

"""Limits, Ordering, Constraints"""
input QueryOptions {
  """Limit number of results"""
  limit: Int

  """Limit number of results by specific field"""
  limitBy: LimitByOption

  """Offset of results, starting from 0"""
  offset: Int

  """Ordering field(s) for ascending"""
  asc: [String!]

  """Ordering field(s) for descending"""
  desc: [String!]
}

"""Solana Receiver"""
type Receiver {
  address: String!
  mintAccount: String!
  type: String!
}

"""Search result item"""
type Result {
  """Blockchain where result is found"""
  network: BlockchainNetwork!

  """Subject in blockchain"""
  subject: Subject!
}

"""Select by reward type"""
input RewardTypeSelector {
  """Type is"""
  is: SolanaRewardType

  """Type not"""
  not: SolanaRewardType

  """Type in the list"""
  in: [SolanaRewardType!]

  """Type not in the list"""
  notIn: [SolanaRewardType!]
}

enum ScriptTypeSelectorSelector {
  """Unknown Transaction"""
  unknown_transaction

  """Peer-to-peer"""
  peer_to_peer_transaction
}

"""Solana Sender"""
type Sender {
  address: String!
  mintAccount: String!
  type: String!
}

"""Smart contract method or event"""
union Signature = Event | Method

enum SignatureTypeSelector {
  """Smart contract method"""
  Function

  """Smart contract event"""
  Event
}

"""Blockchain smart contract"""
type SmartContract {
  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract Type"""
  contractType: SmartContractType!

  """Smart Contract Protocol Type"""
  protocol: String
}

enum SmartContractArgumentsUniq {
  """Unique signatures count"""
  signatures

  """Unique values"""
  values

  """Calls or events"""
  calls

  """Unique transactions count"""
  txs

  """Unique transaction senders"""
  senders

  """Unique callers count"""
  callers

  """Unique smart contracts count"""
  smart_contracts

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

enum SmartContractCallsUniq {
  """Calls"""
  calls

  """Unique transactions count"""
  txs

  """Unique transaction senders"""
  senders

  """Unique callers count"""
  callers

  """Unique smart contracts count"""
  smart_contracts

  """Unique smart contract methods count"""
  smart_contract_methods

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

type SmartContractReadonlyAttribute {
  """Value as address if applicable"""
  address: EthereumAddressInfo

  """Method name"""
  name: String!

  """Method return type"""
  type: String!

  """Method return value"""
  value: String!
}

enum SmartContractType {
  """Not A Smart contract"""
  None

  """General Purpose Smart contract"""
  Generic

  """Smart contract for token derivatives"""
  MarginPositionToken

  """Multi signature wallet"""
  Multisig

  """Token"""
  Token

  """Token Sale"""
  TokenSale

  """Decentralized exchange"""
  DEX

  """Transaction Execution Approval Language"""
  TEAL
}

"""Selector of smart contract type"""
input SmartContractTypeSelector {
  """Smart Contract type is"""
  is: SmartContractType

  """Smart Contract type not"""
  not: SmartContractType

  """Smart Contract type in the list"""
  in: [SmartContractType!]

  """Smart Contract type not in the list"""
  notIn: [SmartContractType!]
}

"""Solana Chain"""
type Solana {
  """BlockRewards of Smart Contract Calls and Events"""
  blockRewards(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, any: [SolanaBlockRewardsFilter!], options: QueryOptions): [SolanaBlockRewards!]

  """Solana Blocks"""
  blocks(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, parentSlot: IntegerSelector, transactionCount: IntegerSelector, rewards: AmountSelector, any: [SolanaBlocksFilter!], options: QueryOptions): [SolanaBlocks!]

  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructions(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: StringSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, external: IntegerSelector, callPath: StringSelector, fee: IntegerSelector, any: [SolanaInstructionsFilter!], options: QueryOptions): [SolanaInstructions!]

  """Solana Transactions"""
  transactions(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, parentSlot: BlockSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, fee: IntegerSelector, signer: HashSelector, transactionFee: AmountSelector, any: [SolanaTransactionsFilter!], options: QueryOptions): [SolanaTransactions!]

  """Currency transfers from/to addresses in crypto currencies"""
  transfers(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, currency: [SolanaCurrencySelector!], any: [SolanaTransfersFilter!], options: QueryOptions): [SolanaTransfers!]
}

"""BlockRewards in Solana  blockchain"""
type SolanaBlockRewards {
  """Account"""
  account(account: BlockSelector): String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector): Float
  any(of: SolanaBlockRewardsMeasureable!): String

  """Hash of the the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: SolanaBlockRewardsUniq): Int

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """Number of block in the blockchains"""
  height(height: BlockSelector): BigInt
  maximum(of: SolanaBlockRewardsMeasureable!, get: SolanaBlockRewardsMeasureable): String
  minimum(of: SolanaBlockRewardsMeasureable!, get: SolanaBlockRewardsMeasureable): String

  """The slot index of this block`s parent"""
  parentSlot(parentSlot: IntegerSelector): BigInt

  """Account balances after the transaction was processed"""
  postBalance(postBalance: IntegerSelector): BigInt

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String

  """Type of reward"""
  rewardType(rewardType: RewardTypeSelector): String

  """The time this transaction was created"""
  time: DateTime
}

input SolanaBlockRewardsFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  reward: AmountSelector
  parentSlot: IntegerSelector
}

enum SolanaBlockRewardsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Number of reward lamports credited or debited by the account"""
  amount

  """The slot index of this block`s parent"""
  parent_slot

  """Account balances after the transaction was processed"""
  post_balance

  """Account"""
  account
}

enum SolanaBlockRewardsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique hash of the the block"""
  block_hash

  """Unique accounts"""
  account

  """Unique currencies"""
  currencies
}

"""Blocks in Solana  blockchain"""
type SolanaBlocks {
  any(of: SolanaBlocksMeasureable!): String

  """Hash of the the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: SolanaBlocksUniq): Int

  """The date this transaction was created"""
  date: Date

  """Number of block in the blockchains"""
  height(height: BlockSelector): BigInt
  maximum(of: SolanaBlocksMeasureable!, get: SolanaBlocksMeasureable): String
  minimum(of: SolanaBlocksMeasureable!, get: SolanaBlocksMeasureable): String

  """The slot index of this block`s parent"""
  parentSlot(parentSlot: IntegerSelector): BigInt

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String
  rewards(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, parentSlot: IntegerSelector, transactionCount: IntegerSelector, rewards: AmountSelector): Float

  """The time this transaction was created"""
  time: DateTime

  """Count of transactions in this block"""
  transactionCount(transactionCount: IntegerSelector): BigInt
}

input SolanaBlocksFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  parentSlot: IntegerSelector
  transactionCount: IntegerSelector
  rewards: AmountSelector
}

enum SolanaBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Number of reward lamports credited or debited by the account"""
  rewards

  """The slot index of this block`s parent"""
  parent_slot

  """Count of transactions in this block"""
  transaction_count
}

enum SolanaBlocksUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Unique Number of block in the blockchains"""
  height
}

"""
Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use
filter bby symbol, bbut it only works if there is just one token with that symbol
"""
input SolanaCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

"""Instructions in Solana  blockchain"""
type SolanaInstructions {
  """Accounts count"""
  accountsCount: Int

  """Action"""
  action(parsedActionName: StringSelector, parsedType: StringSelector): Action
  any(of: SolanaInstructionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): BlockExtended

  """Call Path"""
  callPath(callPath: StringSelector): String
  count(uniq: SolanaInstructionsUniq): Int

  """The date this transaction was created"""
  date: Date

  """External"""
  external(external: IntegerSelector): BigInt

  """External Action"""
  externalAction(externalParsedActionName: StringSelector): ExternalAction

  """External Program"""
  externalProgram(externalProgramId: StringSelector, externalProgramName: StringSelector, externalParsedProgramName: StringSelector): Program

  """Fee Payer"""
  feePayer(feePayer: HashSelector): String

  """Parsed Action Name"""
  log: Log
  maximum(of: SolanaInstructionsMeasureable!, get: SolanaInstructionsMeasureable): String
  minimum(of: SolanaInstructionsMeasureable!, get: SolanaInstructionsMeasureable): String

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String

  """Program"""
  program(programId: StringSelector, programName: StringSelector, parsedProgramName: StringSelector): Program

  """Transaction Hash"""
  signature(signature: HashSelector): String

  """Successed or failed"""
  success(success: BooleanSelector): Boolean

  """Transaction Index"""
  transactionIndex(transactionIndex: IntegerSelector): BigInt
}

input SolanaInstructionsFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
}

enum SolanaInstructionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Transaction Hash"""
  signature

  """Transaction Fee"""
  fee
}

enum SolanaInstructionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature
}

enum SolanaNetwork {
  """Solana Mainnat"""
  solana
}

enum SolanaRewardType {
  """fee type"""
  Fee

  """rent type"""
  Rent

  """voing type"""
  Voting

  """staking type"""
  Staking
}

"""Transactions in Solana  blockchain"""
type SolanaTransactions {
  any(of: SolanaTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): BlockExtended
  count(uniq: SolanaTransactionsUniq): Int

  """The date this transaction was created"""
  date: Date

  """Error"""
  error(error: StringSelector): String

  """Fee Payer"""
  feePayer(feePayer: HashSelector): String
  maximum(of: SolanaTransactionsMeasureable!, get: SolanaTransactionsMeasureable): String
  minimum(of: SolanaTransactionsMeasureable!, get: SolanaTransactionsMeasureable): String

  """The slot index of this block`s parent"""
  parentSlot(parentSlot: BlockSelector): BigInt

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String

  """
  Recent blockhash prevents duplication and to give transactions lifetimes
  """
  recentBlockHash(recentBlockHash: HashSelector): String

  """Transaction Hash"""
  signature(signature: StringSelector): String

  """Accounts` public keys"""
  signer(signer: HashSelector): String

  """Successed or failed"""
  success(success: BooleanSelector): Boolean
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, parentSlot: BlockSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, fee: IntegerSelector, signer: HashSelector, transactionFee: AmountSelector): Float

  """Transaction Index"""
  transactionIndex(transactionIndex: IntegerSelector): BigInt
}

input SolanaTransactionsFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  parentSlot: BlockSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  success: BooleanSelector
  fee: IntegerSelector
  signer: HashSelector
  transactionFee: AmountSelector
}

enum SolanaTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """The slot index of this block`s parent"""
  parent_slot

  """Transaction Hash"""
  signature

  """Transaction Fee"""
  fee

  """Transaction Fee"""
  transaction_fee
}

enum SolanaTransactionsUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature

  """Accounts` public key"""
  signer
}

"""Currency transfers from/to addresses in crypto currencies"""
type SolanaTransfers {
  """Action"""
  action(parsedActionName: StringSelector, parsedType: StringSelector): Action
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, currency: [SolanaCurrencySelector!]): Float
  any(of: SolanaTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): BlockExtended

  """Call Path"""
  callPath(callPath: StringSelector): String
  count(uniq: SolanaTransfersUniq): BigInt

  """Currency of transfer"""
  currency: Currency

  """The date this transaction was created"""
  date: Date

  """Action"""
  externalAction(externalParsedActionName: StringSelector): ExternalAction

  """External Parsed"""
  externalParsed(externalParsed: IntegerSelector): Int

  """Parsed Type"""
  externalParsedType(externalParsedType: StringSelector): String

  """External Program"""
  externalProgram(externalProgramId: StringSelector, externalProgramName: StringSelector, externalParsedProgramName: StringSelector): Program

  """Fee Payer"""
  feePayer(feePayer: HashSelector): String
  maximum(of: SolanaTransfersMeasureable!, get: SolanaTransfersMeasureable): String
  minimum(of: SolanaTransfersMeasureable!, get: SolanaTransfersMeasureable): String

  """Parsed Action Name"""
  parsedActionName(parsedActionName: StringSelector): String

  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String

  """Program"""
  program(programId: StringSelector, programName: StringSelector, parsedProgramName: StringSelector): Program

  """Receiver"""
  receiver: Receiver

  """Sender"""
  sender: Sender

  """Transaction Hash"""
  signature(signature: HashSelector): String

  """Successed or failed"""
  success(success: BooleanSelector): Boolean

  """Transaction Index"""
  transactionIndex(transactionIndex: IntegerSelector): BigInt

  """Transfer Type"""
  transferType(transferType: SolanaTransferTypeSelector): String
}

input SolanaTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  external: StringSelector
  callPath: StringSelector
  senderAddress: StringSelector
  senderType: StringSelector
  receiverAddress: StringSelector
  receiverType: StringSelector
  transferType: SolanaTransferTypeSelector
  currency: [SolanaCurrencySelector!]
}

enum SolanaTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Hash of the the block"""
  block_hash

  """Number of block in the blockhains"""
  height

  """The block hash of this block`s parent"""
  previous_block_hash

  """Transaction Hash"""
  signature

  """Transaction Fee"""
  fee_payer

  """Transfer Type"""
  transfer_type

  """Amount Transfers"""
  amount
}

enum SolanaTransfersUniq {
  """Unique time"""
  times

  """Unique date count"""
  dates

  """Number of block in the blockchains"""
  height

  """Transaction Hash"""
  signature

  """Transfer From"""
  sender_address

  """Transfer To"""
  receiver_address
}

enum SolanaTransferType {
  """Transfer"""
  transfer

  """Self"""
  self

  """Mint"""
  mint

  """Create Account"""
  create_account

  """Close Account"""
  close_account

  """Rent Exemption"""
  rent_exemption

  """Stake"""
  stake

  """Stake Withdraw"""
  stake_withdraw

  """Trade Unknown"""
  trade_unknown

  """Burn"""
  burn

  """Vote"""
  vote

  """Nonce Withdraw"""
  nonce_withdraw
}

"""Select by transfer type"""
input SolanaTransferTypeSelector {
  """Type is"""
  is: SolanaTransferType

  """Type not"""
  not: SolanaTransferType

  """Type in the list"""
  in: [SolanaTransferType!]

  """Type not in the list"""
  notIn: [SolanaTransferType!]
}

"""Select by ID"""
input StringIdSelector {
  """ID is"""
  is: String

  """ID not"""
  not: String

  """ID in the list"""
  in: [String!]

  """ID not in the list"""
  notIn: [String!]
}

"""Select by string"""
input StringSelector {
  """String is"""
  is: String

  """String not"""
  not: String

  """String in the list"""
  in: [String!]

  """String not in the list"""
  notIn: [String!]
}

"""Search result subject"""
union Subject = Address | Currency | HederaAccount | SmartContract | TransactionHash

"""Time Interval"""
type TimeInterval {
  day(count: Int, format: String): String!
  hour(count: Int, format: String): String!
  minute(count: Int, format: String): String!
  month(count: Int, format: String): String!
  second(count: Int, format: String): String!
  year(count: Int, format: String): String!
}

"""Timestamp"""
type Timestamp {
  """Nanoseconds"""
  nanoseconds: BigInt!
  time: ISO8601Date!
}

"""Select trade by ID"""
input TradeIdSelector {
  """Trade ID is"""
  is: String

  """Trade ID not"""
  not: String

  """Trade ID in the list"""
  in: [String!]

  """Trade ID not in the list"""
  notIn: [String!]
}

enum TradeSide {
  """Buy side"""
  BUY

  """Sell side"""
  SELL
}

"""Blockchain transaction"""
type TransactionHash {
  """Hash hex representation"""
  hash: String!
}

"""Blockchain transaction"""
type TransactionHashIndex {
  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0-based"""
  index: String!
}

"""Blockchain transaction"""
type TransactionHashIndexValues {
  """Hash hex representation"""
  hash: String!

  """Transaction index in block, 0-based"""
  index: String!

  """Transaction value in input"""
  valueIn: Float!

  """Transaction value in output"""
  valueOut: Float!
}

"""Blockchain transaction with value"""
type TransactionHashValue {
  """Hash hex representation"""
  hash: String!

  """Transaction value"""
  value: Float!
}

"""Transaction result"""
type TransactionResult {
  """Result ID"""
  id: Int!

  """Result name"""
  name: String!
}

"""Identification of transaction source as client application"""
type TransactionSource {
  """ID numeric"""
  code: Int!

  """Name"""
  name: String!
}

enum TransfersUniq {
  """Transfers"""
  transfers

  """Unique transactions count"""
  txs

  """Unique senders count"""
  senders

  """Unique receivers count"""
  receivers

  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Unique currencies"""
  currencies
}

"""Select by type of transfer"""
input TransferTypeSelector {
  """Transfer Type is"""
  is: FilecoinTransferType

  """Transfer Type not"""
  not: FilecoinTransferType

  """Transfer Type in the list"""
  in: [FilecoinTransferType!]

  """Transfer Type not in the list"""
  notIn: [FilecoinTransferType!]
}

"""Tron Chain"""
type Tron {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [TronAddressInfo!]!

  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!], any: [TronBlockFilter!], options: QueryOptions): [TronBlocks!]

  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [TronCoinpath!]

  """Blockchain Embedded Contracts"""
  contracts(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean, any: [TronContractFilter!], options: QueryOptions): [TronSmartContracts!]

  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, any: [TronSmartContractCallFilter!], options: QueryOptions): [TronSmartContractCalls!]

  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, any: [TronSmartContractEventFilter!], options: QueryOptions): [TronSmartContractEvents!]

  """Blockchain Embedded Contracts"""
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean, any: [TronTradeFilter!], options: QueryOptions): [TronTrades!]

  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector, any: [TronTransactionFilter!], options: QueryOptions): [TronTransactions!]

  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [TronTransferFilter!], options: QueryOptions): [TronTransfers!]
}

"""Address detailed information for Tron network"""
type TronAddressInfo {
  """String address representation"""
  address: String!

  """Annotations ( tags ), if exists"""
  annotation: String

  """Smart Contract if exists on the address"""
  smartContract: TronSmartContractInfo
}

input TronBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  witness: AddressSelector
  version: IntegerSelector
  parentBlockHash: [HashSelector!]
}

"""Blocks in Tron blockchain"""
type TronBlocks {
  any(of: TronBlocksMeasureable!): String
  count(uniq: TronBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!]): Int

  """Calendar date"""
  date: Date

  """Block hash"""
  hash(blockHash: [HashSelector!]): String!

  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String
  minimum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String

  """Parent block hash"""
  parentBlockHash(parentBlockHash: [HashSelector!]): String!

  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime

  """TX Trie Root Hash"""
  txTrieRoot: String!

  """Block version"""
  version(version: IntegerSelector): Int

  """Block witness"""
  witness(witness: AddressSelector): Address

  """Witness signature"""
  witnessSignature: String!
}

enum TronBlocksMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Block hash"""
  block_hash

  """Block Witness address"""
  witness

  """Block Version"""
  version
}

enum TronBlocksUniq {
  """Unique witness count"""
  witnesses

  """Unique date count"""
  dates
}

enum TronCallsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash

  """Call depth"""
  call_depth
}

"""Coinpath"""
type TronCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String

  """Block where transaction is included"""
  block: Block

  """Count of transfers"""
  count: Int

  """Currency of transfer"""
  currency: Currency

  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String

  """Receiver address"""
  receiver: TronAddressInfo

  """Sender address"""
  sender: TronAddressInfo

  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

input TronContractFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txOwner: AddressSelector
  contractType: TronContractTypeSelector
  currency: TronCurrencySelector
  success: Boolean
}

enum TronContractsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Transaction owner"""
  tx_owner

  """Contract"""
  contract_type
}

enum TronContractType {
  """Account Create"""
  AccountCreate

  """Account Permission Update"""
  AccountPermissionUpdate

  """Account Update"""
  AccountUpdate

  """Asset Issue"""
  AssetIssue

  """Clear ABI"""
  ClearABI

  """Create Smart"""
  CreateSmart

  """Exchange Create"""
  ExchangeCreate

  """Exchange Inject"""
  ExchangeInject

  """Exchange Transaction"""
  ExchangeTransaction

  """Exchange Withdraw"""
  ExchangeWithdraw

  """Freeze Balance"""
  FreezeBalance

  """Participate Asset Issue"""
  ParticipateAssetIssue

  """Proposal Approve"""
  ProposalApprove

  """Proposal Create"""
  ProposalCreate

  """Proposal Delete"""
  ProposalDelete

  """Set Account Id"""
  SetAccountId

  """Transfer"""
  Transfer

  """Transfer Asset"""
  TransferAsset

  """Trigger Smart"""
  TriggerSmart

  """Unfreeze Asset"""
  UnfreezeAsset

  """Unfreeze Balance"""
  UnfreezeBalance

  """Update Asset"""
  UpdateAsset

  """Update Brokerage"""
  UpdateBrokerage

  """Update Energy Limit"""
  UpdateEnergyLimit

  """Update Setting"""
  UpdateSetting

  """Vote Witness"""
  VoteWitness

  """Withdraw Balance"""
  WithdrawBalance

  """Witness Create"""
  WitnessCreate

  """Witness Update"""
  WitnessUpdate
}

"""Select contract type(s)"""
input TronContractTypeSelector {
  """Contract type is"""
  is: TronContractType

  """Contract type not"""
  not: TronContractType

  """Contract type in the list"""
  in: [TronContractType!]

  """Contract type not in the list"""
  notIn: [TronContractType!]
}

"""
Currency selector in Tron blockchain.
Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
"""
input TronCurrencySelector {
  """Currency is"""
  is: String

  """Currency not"""
  not: String

  """Currency in the list"""
  in: [String!]

  """Currency not in the list"""
  notIn: [String!]
}

enum TronEventsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Action From"""
  tx_from

  """Action To"""
  tx_to

  """Smart Contract"""
  smart_contract

  """Smart Contract Method Name"""
  signature_name

  """Smart Contract Method Signature"""
  signature

  """Smart Contract Method Signature Hash"""
  signature_hash
}

"""Tron smart contract"""
type TronSmartContract {
  """Smart Contract Address"""
  address: Address!

  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

input TronSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

"""Smart Contract Calls"""
type TronSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  any(of: TronCallsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """
  Depth of the call. Empty string for external call, then counted as 0...N, and
  the next layer is added through '-'. For example 0-3-9.
  """
  callDepth: String

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float

  """
  External call executed explicitly by caller. Internal calls executed by smart contracts.
  """
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  maximum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  minimum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float

  """Smart contract being called"""
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input TronSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""Smart Contract Events"""
type TronSmartContractEvents {
  any(of: TronEventsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector): Int

  """Calendar date"""
  date: Date
  maximum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String
  minimum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String

  """Smart contract being Evented"""
  smartContract(smartContractAddress: AddressSelector): TronSmartContract

  """Contract method invoked"""
  smartContractEvent(smartContractEvent: EventSelector): Event

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

"""Blockchain smart contract"""
type TronSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType

  """Token implemented in this smart contract"""
  currency: Currency

  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Contracts"""
type TronSmartContracts {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  any(of: TronContractsMeasureable!): String

  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Contract type"""
  contractType(contractType: TronContractTypeSelector): TronContractType

  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Int

  """Currency of transfer"""
  currency(currency: TronCurrencySelector): Currency

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  maximum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  minimum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float

  """
  True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API.
  """
  success(success: [Boolean!]): Boolean

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Transactio owner from address"""
  txOwner(txOwner: AddressSelector): Address
}

input TronTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: AddressSelector
  seller: AddressSelector
  buyCurrency: TronCurrencySelector
  sellCurrency: TronCurrencySelector
  contractType: TronContractTypeSelector
  amountSell: [AmountSelector!]
  amountBuy: [AmountSelector!]
  exchangeId: IntIdSelector
  success: Boolean
}

"""Currency Trades from/to addresses in crypto currencies"""
type TronTrades {
  amountBuy(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  amountSell(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  any(of: TronTradesMeasureable!): String

  """Block where Trade transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Buy Currency of Trade"""
  buyCurrency(buyCurrency: TronCurrencySelector): Currency

  """Trade buyer"""
  buyer(buyer: AddressSelector): Address

  """Contract type"""
  contractType(contractType: TronContractTypeSelector): TronContractType
  count(uniq: TronTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Int

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float

  """exchange_id"""
  exchangeId(exchangeId: IntIdSelector): Int
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  maximum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  minimum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float

  """Sell Currency of Trade"""
  sellCurrency(sellCurrency: TronCurrencySelector): Currency

  """Trade seller"""
  seller(seller: AddressSelector): Address

  """Transfer succeeded"""
  success(success: Boolean): Boolean

  """Transaction hash where Trade happened"""
  txHash(txHash: HashSelector): String
}

enum TronTradesMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount Sell"""
  amount_sell

  """Amount Sell"""
  amount_buy

  """Buyer"""
  buyer

  """Seller"""
  seller

  """Buy Currency symbol"""
  buy_currency_symbol

  """Buy Currency name"""
  buy_currency_name

  """Buy Token address"""
  buy_currency_address

  """Buy Token address"""
  buy_token_id

  """Buy Token type"""
  buy_token_type

  """Buy Currency symbol"""
  sell_currency_symbol

  """Buy Currency name"""
  sell_currency_name

  """Buy Token address"""
  sell_currency_address

  """Buy Token address"""
  sell_token_id

  """Buy Token type"""
  sell_token_type

  """Exchange ID"""
  exchange_id

  """Contract Type"""
  contract_type
}

enum TronTradesUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates

  """Sellers count"""
  sellers

  """Buyers count"""
  buyers

  """Buy currencies"""
  buy_currencies

  """Sell currencies"""
  sell_currencies

  """Exchange IDs"""
  exchanges
}

input TronTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  refBlockHash: [HashSelector!]
  contractAddress: AddressSelector
}

"""Transactions in Tron blockchain"""
type TronTransactions {
  any(of: TronTransactionsMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Contract Address"""
  contractAddress(contractAddress: AddressSelector): Address
  count(uniq: TronTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int

  """Calendar date"""
  date: Date
  energyFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  """Expiration"""
  expiration: Int!
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  """Fee Limit"""
  feeLimit: Int!

  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!

  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  internalTransactionsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  logsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  maximum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  minimum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  netFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float

  """Ref block Hash hex representation"""
  refBlockHash(refBlockHash: [HashSelector!]): String!

  """Result message"""
  result: String

  """Signatures"""
  signatures: String!

  """Success"""
  success(success: Boolean): Boolean
}

enum TronTransactionsMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Fee"""
  fee

  """Fee Limit"""
  fee_limit

  """Energy Fee"""
  energy_fee

  """Net usage"""
  net_usage

  """Internal transactions count"""
  internal_transactions_count
}

enum TronTransactionsUniq {
  """Unique blocks"""
  blocks

  """Unique date count"""
  dates
}

input TronTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: TronCurrencySelector
  contractType: TronContractTypeSelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type TronTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: TronTransfersMeasureable!): String

  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block

  """Contract type"""
  contractType(contractType: TronContractTypeSelector): TronContractType
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int

  """Currency of transfer"""
  currency(currency: TronCurrencySelector): Currency

  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float

  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String

  """
  External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts.
  """
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  minimum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float

  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address

  """Transfer sender"""
  sender(sender: AddressSelector): Address

  """Transfer succeeded"""
  success(success: Boolean): Boolean

  """Action from address"""
  txFrom(txFrom: AddressSelector): Address

  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String

  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

enum TronTransfersMeasureable {
  """Date"""
  date

  """Time"""
  time

  """Block"""
  block

  """Transaction hash"""
  tx_hash

  """Amount"""
  amount

  """Sender"""
  sender

  """Receiver"""
  receiver

  """Currency symbol"""
  currency_symbol

  """Token address"""
  currency_address

  """Token ID"""
  token_id

  """Token type"""
  token_type
}

"""Selector of index of transaction in block"""
input TxIndexSelector {
  """Tx index is"""
  is: Int

  """Tx index not"""
  not: Int

  """Tx index in the list"""
  in: [Int!]

  """Tx index not in the list"""
  notIn: [Int!]
}

"""Select transactions by subtype"""
input TxSubtypeSelector {
  """Transaction SubType is"""
  is: AlgorandTxSubType

  """Transaction SubType not"""
  not: AlgorandTxSubType

  """Transaction SubType in the list"""
  in: [AlgorandTxSubType!]

  """Transaction SubType not in the list"""
  notIn: [AlgorandTxSubType!]
}

"""Select transactions by type"""
input TxTypeSelector {
  """Transaction Type is"""
  is: AlgorandTxType

  """Transaction Type not"""
  not: AlgorandTxType

  """Transaction Type in the list"""
  in: [AlgorandTxType!]

  """Transaction Type not in the list"""
  notIn: [AlgorandTxType!]
}

